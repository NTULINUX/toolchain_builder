#!/usr/bin/env bash
#
# Copyright (C) 2016 Alec Ari <neotheuser@ymail.com>
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

# TODO: Finish initial toolchain
# TODO: Finish Binutils 2nd/3rd pass (Gold linker + LTO + ISL)
# TODO: Glibc 2nd/3rd pass
# TODO: GCC 2nd/3rd pass (Gold linker + LTO + ISL)
# TODO: Possible long-term reach goal: Create a small chroot environment using git toolchain

# printf because this is a C program (not really, just don't like echo)
printf "	NTU's complete bleeding edge native x86/amd64 toolchain builder\n"
printf "	Copyright (C) 2016 Alec Ari\n\n"
sleep 3

# This is here to ensure we don't accidentally break something bad
printf "	Making sure we are not root...\n"
if [[ ${EUID} = 0 ]] ; then
	printf "	This script must not be run as root.\n"
	exit 1
else
	printf "	Not root. Good.\n"
fi

# Environment sanity
unset STARTDIR
STARTDIR="${PWD}"

if [[ -w "${STARTDIR}" ]] ; then
	printf "	User has write permissions to ${STARTDIR}\n"
else
	printf "	Please switch to a non-root writeable directory, such as home.\n"
	exit 1
fi

# NOTICE: A value of 1 to the config file means true,
# while 0 means false. This logic is similar to:
# i.e. #define X_Y_Z 1 (for true) therefor NOT a typo

# Reduce lengthly printf lines
REPORT_BUG_EXIT="\n\tPlease report bug to script maintainer.\n\tExiting.\n"

# Load config if present
unset TOOLCHAIN_CONFIG
TOOLCHAIN_CONFIG="${STARTDIR}/toolchain_builder.config"
printf "	Checking for pre-existing config file...\n"
if [[ -a "${TOOLCHAIN_CONFIG}" ]] ; then
	printf "	Config file found. Loading...\n"
	source ${TOOLCHAIN_CONFIG}
	printf "	Loaded.\n"
else
	printf "	Config file not found. Creating one.\n"
	touch ${TOOLCHAIN_CONFIG}
	echo "# Automatically generated by NTU's toolchain builder" &> ${TOOLCHAIN_CONFIG}
fi

# Determine if we use lib or lib64
# Used by prepare_libdir
check_arch ()
{
if [[ -z ${LIB64} ]] ; then
	return 0
else
	printf "	Detecting kernel bitness...\n"
	unset ARCH_UNAME
	ARCH_UNAME=`uname -m`
	if [[ ${ARCH_UNAME} == *64 ]] ; then
		printf "	64-bit\n"
		LIB64=1 && echo LIB64=${LIB64} >> ${TOOLCHAIN_CONFIG}
	elif [[ ${ARCH_UNAME} == *86 ]] ; then
		printf "	32-bit\n"
		LIB64=0 && echo LIB64=${LIB64} >> ${TOOLCHAIN_CONFIG}
	else
	printf "	Unable to detect bitness.\n"
	printf "	Only x86 and amd64 platforms supported.\n"
	exit 1
fi
}
check_arch

# Redirect stdout (1) and stderr (2) to /dev/null (keep quiet)
# print error if type fails and exit with >0 exit status
check_prerequisites ()
{
if [[ ${SYSTEM_OK} == 1 ]] ; then
	printf "	System already checked for prerequisites, all ok.\n"
	return 0
else
	printf "	Checking system for prerequisites...\n"
	type make > /dev/null 2>&1 || { printf "	Cannot find make. Exiting.\n" ; exit 1 ; }
	type gcc > /dev/null 2>&1 || { printf "	Cannot find GCC. Exiting.\n" ; exit 1 ; }
	type g++ > /dev/null 2>&1 || { printf "	Cannot find G++. Exiting.\n" ; exit 1 ; }
	type ld > /dev/null 2>&1 || { printf "	Please install Binutils. Exiting.\n" ; exit 1 ; }
	type libtool > /dev/null 2>&1 || { printf "	Cannot find libtool. Exiting.\n" ; exit 1 ; }
	type wget > /dev/null 2>&1 || { printf "	Cannot find wget. Exiting.\n" ; exit 1 ; }
	type git > /dev/null 2>&1 || { printf "	Cannot find git. Exiting.\n" ; exit 1 ; }
	type patch > /dev/null 2>&1 || { printf "	Cannot find patch. Exiting.\n" ; exit 1 ; }
	type autoconf > /dev/null 2>&1 || { printf "	Cannot find autoconf. Exiting.\n" ; exit 1 ; }
	type automake > /dev/null 2>&1 || { printf "	Cannot find automake. Exiting.\n" ; exit 1 ; }
	type grep > /dev/null 2>&1 || { printf "	Cannot find grep. Exiting.\n" ; exit 1 ; }
	type gawk > /dev/null 2>&1 || { printf "	Cannot find gawk. Exiting.\n" ; exit 1 ; }
	printf "	Obvious required tools found.\n"
	SYSTEM_OK=1 && echo SYSTEM_OK=${SYSTEM_OK} >> ${TOOLCHAIN_CONFIG}
fi
}

# Probably not the BEST way to check, but it gets the job done
check_vanilla_toolchain ()
{
if [[ ${GENTOO_PASS} == 1 || ${GENERIC_TRUE} == 1 ]] ; then
	printf "	System already passed compiler check.\n"
else
	unset GENTOO_TRUE
	unset GENERIC_TRUE
	printf "	Is this a Gentoo system?\n"
	if [[ `ls /etc/env.d/gcc/config*` ]] ; then
		printf "	Yes.\n" && GENTOO_TRUE=1
	else
		printf "	No, assuming working toolchain.\n"
		GENERIC_TRUE=1 && echo GENERIC_TRUE=${GENERIC_TRUE} >> ${TOOLCHAIN_CONFIG}
	fi

	unset GENTOO_PASS
	if [[ ${GENTOO_TRUE} == 1 ]] ; then
		GCC_ENV_CONF="`cat /etc/env.d/gcc/config*`"
		if [[ ${GCC_ENV_CONF} == *vanilla && ${GENTOO_TRUE} == 1 ]] ; then
			printf "	Good, vanilla toolchain.\n"
			GENTOO_PASS=1 && echo GENTOO_PASS=${GENTOO_PASS} >> ${TOOLCHAIN_CONFIG}
		else
			printf "	Not vanilla GCC, this may cause a GCC build failure
	as -fPIC and potentially other CFLAGS are known to issues.
	You may comment the following line out at your own risk. If you do,
	please report your success, your feedback is greatly appreciated.\n"
		exit 1
		fi
	fi
fi
}
check_vanilla_toolchain

# unset in case set previously
unset CFLAGS
unset CXXFLAGS

# srcdir is taken so we have to make this more unique
unset TOOLCHAIN_SRCDIR
unset TOOLCHAIN_BINDIR

unset LINUX_TOOLCHAIN_SRCDIR
unset BINUTILS_TOOLCHAIN_SRCDIR
unset GLIBC_TOOLCHAIN_SRCDIR
unset GCC_TOOLCHAIN_SRCDIR

unset BINUTILS_GIT
unset GLIBC_GIT
unset GCC_GIT
unset BINUTILS_GIT_BRANCH
unset GCC_GIT_BRANCH
unset GLIBC_GIT_BRANCH

unset LINUX_VER
unset LINUX_LOC
unset GMP_LOC
unset MPFR_LOC
unset MPC_LOC
unset ISL_LOC
unset GCC_PATCH_LOC

unset CORES

#
# User modifiable variables
#

TOOLCHAIN_SRCDIR="${STARTDIR}/toolchain-src"
TOOLCHAIN_BINDIR="${STARTDIR}/toolchain-bin"
TOOLCHAIN_PATCHDIR="${STARTDIR}/patches"

LINUX_VER="4.8.10"
# if git: LINUX_TOOLCHAIN_SRCDIR="${TOOLCHAIN_SRCDIR}/linux"
LINUX_TOOLCHAIN_SRCDIR="${TOOLCHAIN_SRCDIR}/linux-${LINUX_VER}"

BINUTILS_TOOLCHAIN_SRCDIR="${TOOLCHAIN_SRCDIR}/binutils-gdb"
GLIBC_TOOLCHAIN_SRCDIR="${TOOLCHAIN_SRCDIR}/glibc"
GCC_TOOLCHAIN_SRCDIR="${TOOLCHAIN_SRCDIR}/gcc"
GMP_TOOLCHAIN_SRCDIR="${TOOLCHAIN_SRCDIR}/gmp"
MPFR_TOOLCHAIN_SRCDIR="${TOOLCHAIN_SRCDIR}/mpfr"
MPC_TOOLCHAIN_SRCDIR="${TOOLCHAIN_SRCDIR}/mpc"
ISL_TOOLCHAIN_SRCDIR="${TOOLCHAIN_SRCDIR}/isl"

BINUTILS_GIT="git://sourceware.org/git/binutils-gdb.git"
GLIBC_GIT="git://sourceware.org/git/glibc.git"
GCC_GIT="git://gcc.gnu.org/git/gcc.git"

# Unstable branches
GCC_GIT_BRANCH="master"

# Stable branches
BINUTILS_GIT_BRANCH="binutils-2_27-branch"

if [[ $GENTOO_TRUE == 1 ]] ; then
	GLIBC_GIT_BRANCH="gentoo/2.24"
else
	GLIBC_GIT_BRANCH="release/2.24/master"
fi

# LINUX_GIT="git://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git"
# LINUX_GIT_BRANCH="master"
# Help speed things up by grabbing latest tarball of Linux instead of git
LINUX_LOC="https://cdn.kernel.org/pub/linux/kernel/v4.x/linux-${LINUX_VER}.tar.xz"

# Prerequisites
GMP_VER="6.1.1"
MPFR_VER="3.1.5"
MPC_VER="1.0.3"
ISL_VER="0.17.1"

GMP_LOC="https://ftp.gnu.org/gnu/gmp/gmp-${GMP_VER}.tar.xz"
MPFR_LOC="http://www.mpfr.org/mpfr-current/mpfr-${MPFR_VER}.tar.xz"
MPC_LOC="ftp://ftp.gnu.org/gnu/mpc/mpc-${MPC_VER}.tar.gz"
ISL_LOC="http://isl.gforge.inria.fr/isl-${ISL_VER}.tar.xz"

# Fixes stupid and highly annoying libstdc++-v3 PIC compiling error
GCC_PIC_PATCH="${TOOLCHAIN_PATCHDIR}/gcc-libstdc-pic.patch"

#
# End of user modifiable variables
#


#
# Fetch sources
#

# Only called if not there or first run
# if git: change this like the other fetch_* funcs
fetch_linux_headers ()
{
	printf "	Fetching Linux sources via wget...\n"

	wget -c ${LINUX_LOC} || \
	{ printf "	Error downloading Linux sources. Exiting.\n" ; exit 1 ; }

	printf "	Decompressing archive...\n"
	tar xf linux-${LINUX_VER}.tar.xz

	test -d linux-${LINUX_VER} || \
	{ printf "	Unexpected error: Linux source directory cannot be found. Exiting.\n" ; exit 1 ; }
}

# These are broken up in case some clone gets interrupted
fetch_binutils ()
{
	printf "	Fetching Binutils via git...\n"
	git clone ${BINUTILS_GIT}
if [[ -d "${BINUTILS_TOOLCHAIN_SRCDIR}" ]] ; then
	cd ${BINUTILS_TOOLCHAIN_SRCDIR}
	git checkout ${BINUTILS_GIT_BRANCH}
else
	printf "	Error cloning Binutils. Exiting.\n"
	exit 1
fi
}

fetch_glibc ()
{
	printf "	Fetching Glibc via git...\n"
	git clone ${GLIBC_GIT}
if [[ -d "${GLIBC_TOOLCHAIN_SRCDIR}" ]] ; then
	cd ${GLIBC_TOOLCHAIN_SRCDIR}
	git checkout ${GLIBC_GIT_BRANCH}
else
	printf "	Error cloning Glibc. Exiting.\n"
	exit 1
fi
}

fetch_gcc ()
{
	printf "	Fetching GCC via git...\n"
	git clone ${GCC_GIT}
if [[ -d "${GCC_TOOLCHAIN_SRCDIR}" ]] ; then
	cd ${GCC_TOOLCHAIN_SRCDIR}
	git checkout ${GCC_GIT_BRANCH}
else
	printf "	Error cloning GCC. Exiting.\n"
	exit 1
fi
}

fetch_gmp ()
{
if [[ ! -d "${GMP_TOOLCHAIN_SRCDIR}" ]] ; then
	printf "	Downloading GMP...\n"
	wget -c ${GMP_LOC} || \
	{ printf "	Error downloading GMP-${GMP_VER}. Exiting.\n" ; exit 1 ; }
	tar xf gmp-${GMP_VER}.tar.xz
	mv -v gmp-${GMP_VER} gmp
else
	return 0
fi
}

fetch_mpfr ()
{
if [[ ! -d "${MPFR_TOOLCHAIN_SRCDIR}" ]] ; then
	printf "	Downloading MPFR...\n"
	wget -c ${MPFR_LOC} || \
	{ printf "	Error downloading MPFR-${MPFR_VER}. Exiting.\n" ; exit 1 ; }
	tar xf mpfr-${MPFR_VER}.tar.xz
	mv -v mpfr-${MPFR_VER} mpfr
else
	return 0
fi
}

fetch_mpc ()
{
if [[ ! -d "${MPC_TOOLCHAIN_SRCDIR}" ]] ; then
	printf "	Downloading MPC...\n"
	wget -c ${MPC_LOC} || \
	{ printf "	Error downloading MPC-${MPC_VER}.\n Exiting.\n" ; exit 1 ; }
	tar zxf mpc-${MPC_VER}.tar.gz
	mv -v mpc-${MPC_VER} mpc
else
	return 0
fi
}

fetch_isl ()
{
if [[ ! -d "${ISL_TOOLCHAIN_SRCDIR}" ]] ; then
	printf "	Downloading ISL...\n"
	wget -c ${ISL_LOC} || \
	{ printf "      Error downloading ISL-${ISL_VER}.\n Exiting.\n" ; exit 1 ; }
	tar xf isl-${ISL_VER}.tar.xz
	mv -v isl-${ISL_VER} isl
else
	return 0
fi
}

fetch_all ()
{
	fetch_linux_headers
	fetch_binutils
	fetch_gcc
	fetch_glibc
	fetch_gmp
	fetch_mpfr
	fetch_mpc
	fetch_isl
}


#
# Update if present, fresh download if not
#

check_linux_srcdir ()
{
	printf "	Checking for kernel source directory...\n"
if [[ -d "${LINUX_TOOLCHAIN_SRCDIR}" ]] ; then
	printf "	Present.\n"
else
	printf "	Not found.\n"
	fetch_linux_headers
fi
}

check_binutils_srcdir ()
{
	printf "	Checking for Binutils git tree...\n"
if [[ -d "${BINUTILS_TOOLCHAIN_SRCDIR}" ]] ; then
	printf "	Directory exists, updating tree...\n"
	cd ${BINUTILS_TOOLCHAIN_SRCDIR}
	git pull
else
	printf "	Not found.\n"
	fetch_binutils
fi
}

check_glibc_srcdir ()
{
	printf "	Checking for Glibc git tree...\n"
if [[ -d "${GLIBC_TOOLCHAIN_SRCDIR}" ]] ; then
	printf "	Directory exists, updating tree...\n"
	cd ${GLIBC_TOOLCHAIN_SRCDIR}
	git pull
else
	printf "	Not found.\n"
	fetch_glibc
fi
}

check_gcc_srcdir ()
{
	printf "	Checking for GCC git tree...\n"
if [[ -d "${GCC_TOOLCHAIN_SRCDIR}" ]] ; then
	printf "	Directory exists, updating tree...\n"
	cd ${GCC_TOOLCHAIN_SRCDIR}
	# In case patch is applied, always reset tree to ensure git pull works
	git reset --hard HEAD
	git pull
else
	printf "	Not found.\n"
	fetch_gcc
fi
}

check_src ()
{
	check_linux_srcdir
	check_binutils_srcdir
	check_glibc_srcdir
	check_gcc_srcdir
}

init_src ()
{
	printf "	Creating source work directory...\n"
	# In case bash screwed up at detecting write access?
	mkdir -p ${TOOLCHAIN_SRCDIR} || \
	{ printf "	Failed to create ${TOOLCHAIN_SRCDIR}. Exiting.\n" ; exit 1 ; }
	cd ${TOOLCHAIN_SRCDIR}
	fetch_all
}

printf "	Checking if ${TOOLCHAIN_SRCDIR} exists...\n"
if [[ -d "${TOOLCHAIN_SRCDIR}" ]] ; then
	printf "	It does.\n"
	cd ${TOOLCHAIN_SRCDIR}
	check_src
else
	printf "	It does not, must be a first run.\n"
	printf "	Welcome! I really hope this script works for you.\n"
	printf "	Please report any bugs to the author of this program.\n"
	init_src
fi


#
# This is where the building starts
#

CORES=`cat /proc/cpuinfo | grep processor | wc -l`

# Always make sure this is a fresh build
# Extra second added for read time
if [[ -d "${TOOLCHAIN_BINDIR}" ]] ; then
	printf "	${TOOLCHAIN_BINDIR} found."
	printf "	Deleting ${TOOLCHAIN_BINDIR} in 5 seconds.\n"
	printf "	This action cannot be undone.\n"
	printf "	Press Control+C to cancel.\n"
	sleep 1
	printf "	5.\n"
	sleep 1
	printf "	4.\n"
	sleep 1
	printf "	3.\n"
	sleep 1
	printf "	2.\n"
	sleep 1
	printf "	1.\n"
	sleep 1
	printf "	Cleaning ${TOOLCHAIN_BINDIR}...\n"
	rm -rf ${TOOLCHAIN_BINDIR}
	printf "	${TOOLCHAIN_BINDIR} removed. Rebuilding toolchain...\n"
fi

#
# Create lib64 with lib symlink if 64-bit
#

prepare_libdir()
{
if [[ $LIB64 == 1 ]] ; then

	mkdir -p ${TOOLCHAIN_BINDIR}/usr/lib64 || \
	{ printf "	Error creating ${TOOLCHAIN_BINDIR}/usr/lib64. Exiting.\n" ; exit 1 ; }

	ln -sfv ${TOOLCHAIN_BINDIR}/usr/lib64 ${TOOLCHAIN_BINDIR}/usr/lib

	TOOLCHAIN_LIBDIR=${TOOLCHAIN_BINDIR}/usr/lib64 && \
	echo TOOLCHAIN_LIBDIR=${TOOLCHAIN_LIBDIR} >> ${TOOLCHAIN_CONFIG}
elif [[ $LIB64 == 0 ]] ; then

	mkdir -p ${TOOLCHAIN_BINDIR}/usr/lib || \
	{ printf "	Error creating ${TOOLCHAIN_BINDIR}/usr/lib. Exiting.\n" ; exit 1 ; }

	TOOLCHAIN_LIBDIR=${TOOLCHAIN_BINDIR}/usr/lib && \
	echo TOOLCHAIN_LIBDIR=${TOOLCHAIN_LIBDIR} >> ${TOOLCHAIN_CONFIG}
fi
}

#
# Linux kernel headers
#

# Always make sure headers are sanitized
install_linux_headers ()
{
	printf "	Installing kernel headers to ${TOOLCHAIN_BINDIR}/usr/include...\n"
	sleep 1

	cd ${LINUX_TOOLCHAIN_SRCDIR}
	make mrproper

if [[ ! -d "DESTDIR" ]] ; then
	mkdir -p DESTDIR
else
	rm -rf DESTDIR/*
fi

	make INSTALL_HDR_PATH="DESTDIR" headers_install

	mkdir -p ${TOOLCHAIN_BINDIR}/usr/include || \
	{ printf "	Error creating ${TOOLCHAIN_BINDIR}/include. Exiting.\n" ; exit 1 ; }

	cp -pr DESTDIR/include/* ${TOOLCHAIN_BINDIR}/usr/include/ || \
	{ printf "	Error installing kernel headers. Exiting.\n" ; exit 1 ; }
}

#
# First pass of Binutils
#

# Possible FIXME
first_pass_binutils ()
{
	printf "	Building first pass Binutils...\n"
	sleep 1

	cp -pr ${ISL_TOOLCHAIN_SRCDIR} ${BINUTILS_TOOLCHAIN_SRCDIR}/
	cd ${BINUTILS_TOOLCHAIN_SRCDIR}

if [[ ! -d "build" ]] ; then
	mkdir -p build
	cd build
else
	cd build
	make distclean
	rm -rf ${BINUTILS_TOOLCHAIN_SRCDIR}/build/*
fi

	../configure \
	--prefix=${TOOLCHAIN_BINDIR}/usr \
	--enable-gold \
	--enable-lto \
	--with-isl \
	--disable-nls \
	--disable-gdb \
	--disable-werror \
	--disable-shared || \
	{ printf "	Binutils configure error. Exiting.\n" ; exit 1 ; }

	make -j${CORES} || \
	{ printf "	Binutils compile error. Exiting.\n" ; exit 1 ; }
	make install || \
	{ printf "	Binutils install error. Exiting.\n" ; exit 1 ; }
	BINUTILS_FIRST_PASS_SUCCESS=1
}

#
# First pass of Glibc GNU C library
#

first_pass_glibc ()
{
	printf "	Building first pass Glibc...\n"
	sleep 1

	cd ${GLIBC_TOOLCHAIN_SRCDIR}

if [[ ! -d "build" ]] ; then
	mkdir -p build
	cd build
else
	cd build
	make distclean
	rm -rf ${GLIBC_TOOLCHAIN_SRCDIR}/build/*
fi

	../configure \
	--prefix=${TOOLCHAIN_BINDIR}/usr \
	--with-binutils=${TOOLCHAIN_BINDIR}/usr/bin \
	--with-headers=${TOOLCHAIN_BINDIR}/usr/include || \
	{ printf "	Glibc configure error. Exiting.\n" ; exit 1 ; }

	make -j${CORES} || \
	{ printf "	Glibc compile error. Exiting.\n" ; exit 1 ; }

	make install || \
	{ printf "	Glibc install error. Exiting.\n" ; exit 1 ; }

	GLIBC_FIRST_PASS_SUCCESS=1
}

# Not the best way, may break with future GCC updates
# Works for now, suggestions welcome
check_pic_patch_gcc ()
{
	unset PIC_PATCH_APPLIED

	printf "	Checking if gcc/libstdc++-v3 is already patched...\n"

	PIC_CONF_NUM="$(grep 'glibcxx_lt_pic_flag="-prefer-pic"' \
	${GCC_TOOLCHAIN_SRCDIR}/libstdc++-v3/configure | wc -l)"

	PIC_CONF_AC_NUM="$(grep 'glibcxx_lt_pic_flag="-prefer-pic"' \
	${GCC_TOOLCHAIN_SRCDIR}/libstdc++-v3/configure.ac | wc -l)"

if [[ ${PIC_CONF_NUM} == 1 && ${PIC_CONF_AC_NUM} == 1 ]] ; then
	PIC_PATCH_APPLIED=0
elif [[ ${PIC_CONF_NUM} == 2 && ${PIC_CONF_AC_NUM} == 2 ]] ; then
	PIC_PATCH_APPLIED=1
else
	printf "	gcc/libstdc++-v3 patch failed.${REPORT_BUG_EXIT}"
	exit 1
fi
}

# Fixes GCC bug #58638
maybe_pic_patch_gcc ()
{
	check_pic_patch_gcc

if [[ ${PIC_PATCH_APPLIED} == 0 ]] ; then
	printf "	libstdc++-v3 PIC patch not applied. Applying...\n"
	cd ${GCC_TOOLCHAIN_SRCDIR}
	patch -p1 < ${GCC_PATCH_LOC} || \
	{ printf "	libstdc++-v3 PIC patch failed.${REPORT_BUG_EXIT}" ; exit 1 ; }
	PIC_PATCH_APPLIED=1
	printf "	libstdc++-v3 PIC patch successful.\n"
elif [[ ${PIC_PATCH_APPLIED} == 1 ]] ; then
	printf "	libstdc++-v3 PIC patch already applied.\n"
else
	printf "	Unable to determine if libstdc++-v3 PIC patch is applied.${REPORT_BUG_EXIT}"
	exit 1
fi
}

# Suggestions welcome on a better way to do this
check_ld_linker_path ()
{
	GCC_CONF_32_H="${GCC_TOOLCHAIN_SRCDIR}/gcc/config/i386/linux.h"
	GCC_CONF_64_H="${GCC_TOOLCHAIN_SRCDIR}/gcc/config/i386/linux64.h"

	printf "	Is GCC using the proper linker?\n"

	CHECK_HARDLINK_32=`grep ${TOOLCHAIN_LIBDIR} ${GCC_CONF_32_H}`
if [[ $? == 0 ]] ; then
	printf "	Yes.\n"
	GCC_CONF_32_H_FIXED=1
elif [[ $? == 1 ]] ; then
	printf " No.\n"
	GCC_CONF_32_H_FIXED=0
else
	printf "	Error detecting if GCC is using proper linker.\n"
	exit 1
fi

	CHECK_HARDLINK_64=`grep ${TOOLCHAIN_LIBDIR} ${GCC_CONF_64_H}`
if [[ $? == 0 ]] ; then
	GCC_CONF_64_H_FIXED=1
elif [[ $? == 1 ]] ; then
	GCC_CONF_64_H_FIXED=0
else
	printf "	Error detecting if GCC is using proper linker.\n"
	exit 1
fi
}

# Removes hardlink to /lib/ld-linux.so.2 and /lib64/ld-linux-x86-64.so.2
# Makes it point to TOOLCHAIN_LIBDIR
maybe_fix_ld_linker_path ()
{
	check_ld_linker_path

if [[ ${GCC_CONF_32_H_FIXED} == 0 && ${GCC_CONF_64_H_FIXED} == 0 ]] ; then
	printf "	GCC linker fix not applied, attempting to fix via sed...\n"

	sed "s#/lib/ld-linux.so.2#${TOOLCHAIN_LIBDIR}/ld-linux.so.2#g" -i ${GCC_CONF_32_H} || \
	{ printf "	Applying 32-bit linker fix failed.${REPORT_BUG_EXIT}"; exit 1 ; }

	sed "s#/lib64/ld-linux-x86-64.so.2#${TOOLCHAIN_LIBDIR}/ld-linux-x86-64.so.2#g" -i ${GCC_CONF_64_H} || \
	{ printf "	Applying 64-bit linker fix failed.${REPORT_BUG_EXIT}"; exit 1 ; }

	printf "	GCC linker fix now applied.\n"
elif [[ ${GCC_CONF_32_H_FIXED} == 1 && ${GCC_CONF_64_H_FIXED} == 1 ]] ; then
	printf "	GCC linker fix already applied.\n"
else
	printf "	Unable to determine if linker fix is applied.${REPORT_BUG_EXIT}"
	exit 1
fi
}

prepare_gcc ()
{
	maybe_pic_patch_gcc
	maybe_fix_ld_linker_path

if [[ ! -d ${GCC_TOOLCHAIN_SRCDIR}/gmp ]] ; then
	printf "	Copying GMP to GCC...\n"

	cp -pr {GMP_TOOLCHAIN_SRCDIR} ${GCC_TOOLCHAIN_SRCDIR}/ || \
	printf "	Error copying GMP to GCC.${REPORT_BUG_EXIT}"

elif [[ ! -d ${GCC_TOOLCHAIN_SRCDIR}/mpfr ]] ; then
	printf "	Copying MPFR to GCC...\n"

	cp -pr {MPFR_TOOLCHAIN_SRCDIR} ${GCC_TOOLCHAIN_SRCDIR}/ || \
	printf "	Error copying MPFR to GCC.${REPORT_BUG_EXIT}"

elif [[ ! -d ${GCC_TOOLCHAIN_SRCDIR}/mpc ]] ; then
	printf "	Copying MPC to GCC...\n"

	cp -pr {MPC_TOOLCHAIN_SRCDIR} ${GCC_TOOLCHAIN_SRCDIR}/ || \
	printf "	Error copying MPC to GCC.${REPORT_BUG_EXIT}"

elif [[ ! -d ${GCC_TOOLCHAIN_SRCDIR}/isl ]] ; then
	printf "	Copying ISL to GCC...\n"

	cp -pr {ISL_TOOLCHAIN_SRCDIR} ${GCC_TOOLCHAIN_SRCDIR}/ || \
	printf "	Error copying ISL to GCC.${REPORT_BUG_EXIT}"

fi
}

gcc_first_pass ()
{
	printf "	Building first pass C/C++ compiler...\n"
	sleep 1

	prepare_gcc

	mkdir -p ${GCC_TOOLCHAIN_SRCDIR}/build
	cd ${GCC_TOOLCHAIN_SRCDIR}/build

	../configure \
	--prefix=${TOOLCHAIN_BINDIR}/usr \
	--with-local-prefix=${TOOLCHAIN_BINDIR}/usr \
	--with-native-system-header-dir=${TOOLCHAIN_BINDIR}/usr/include \
	--enable-languages=c,c++ \
	--enable-gold \
	--enable-lto \
	--with-isl \
	--disable-nls \
	--disable-shared \
	--disable-multilib \
	--disable-libatomic \
	--disable-libgomp \
	--disable-libmpx \
	--disable-libquadmath \
	--disable-libssp \
	--disable-libvtv  \
	--disable-libstdcxx-pch \
	--disable-werror \
	--disable-libcilkrts \
	--disable-libitm \
	--disable-libsanitizer || \
	{ printf "	Configure error. Exiting.\n" ; exit 1 ; }

	make -j${CORES} || \
	{ printf "	Compile error. Exiting.\n" ; exit 1 ; }

	make install || \
	{ printf "	Install error. Exiting.\n" ; exit 1 ; }

	GCC_FIRST_PASS_SUCCESS=1
}


# TODO: Finish second pass (Binutils, Glibc, GCC)
# Do we really need a third pass? Can we get Gold+LTO+ISL without one? Time will tell.
determine_pass_gcc ()
{
	gcc_first_pass

if [[ ${GCC_FIRST_PASS_SUCCESS} == 1 ]] ; then
	gcc_second_pass
elif [[ ${GCC_SECOND_PASS_SUCCESS} == 1 ]] ; then
	printf "	Final GCC is built.\n"
	printf "	Success!\n"
	printf "	Toolchain complete! Nothing more to do! Exiting.\n"
	exit 0
else
	printf "	Unable to determine what GCC stage to build.${REPORT_BUG_EXIT}"
	exit 1
fi
}


prepare_libdir

install_linux_headers

# TODO: Change to determine
# first_pass_binutils

# TODO: Change to determine
# first_pass_glibc

# determine_pass_gcc
