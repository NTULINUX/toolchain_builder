#!/usr/bin/env bash
#
# Copyright (C) 2016 - 2017 Alec Ari <neotheuser@ymail.com>
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

# TODO: Possible long-term reach goal: Create a small chroot environment using git toolchain
# May be necessary as GLIBC has hard codes set that I cannot find via git grep
# Gentoo prefix development team may have some answers

# printf because this is now a C program
printf "\n\tNTU's complete bleeding edge native x86/amd64 toolchain builder
\tCopyright (C) 2016 - 2017 Alec Ari\n"
sleep 3

# This is here to ensure we don't accidentally break something bad
printf "\n\tMaking sure we are not root...\n"
if [[ "${EUID}" == 0 ]] ; then
	printf "\tThis script must not be run as root.\n\tExiting.\n"
	exit 1
else
	printf "\tNot root. Good.\n"
fi

# Environment sanity
unset STARTDIR
STARTDIR="${PWD}"

if [[ -w "${STARTDIR}" ]] ; then
	printf "\n\tUser has write permissions to %s\n" "${STARTDIR}"
else
	printf "\n\tPlease switch to a user writeable directory, such as your home folder.\n"
	exit 1
fi

# NOTICE: A value of 1 to the config file means true,
# while 0 means false. This logic is similar to:
# i.e. #define X_Y_Z 1 (for true) therefor NOT a typo

# Reduce lengthly printf lines
REPORT_BUG_EXIT="\n\tPlease report bug to script maintainer.\n\tExiting.\n"

#
# User configuation:
# You may modify these default settings before running this script to your liking
#

user_defaults ()
{
	unset TOOLCHAIN_CONFIG
	unset TOOLCHAIN_SRCDIR
	unset TOOLCHAIN_BINDIR
	unset TOOLCHAIN_PATCHDIR
	unset CORES
	unset LINUX_VER
	unset GMP_VER
	unset MPFR_VER
	unset MPC_VER
	unset ISL_VER
	unset BINUTILS_GIT_BRANCH
	unset GLIBC_GIT_BRANCH
	unset GCC_GIT_BRANCH

	TOOLCHAIN_CONFIG="${STARTDIR}/toolchain_builder.config"
	TOOLCHAIN_SRCDIR="${STARTDIR}/toolchain-src"
	TOOLCHAIN_BINDIR="${STARTDIR}/toolchain-bin"
	TOOLCHAIN_PATCHDIR="${STARTDIR}/patches"
	CORES=$(grep -c processor /proc/cpuinfo)
	LINUX_VER="4.11.6"
	GMP_VER="6.1.2"
	MPFR_VER="3.1.5"
	MPC_VER="1.0.3"
	ISL_VER="0.18"
	BINUTILS_GIT_BRANCH="master"
	GLIBC_GIT_BRANCH="master"
	GCC_GIT_BRANCH="master"
}

#
# End of user configuration
#

user_defaults

#
# DO NOT MODIFY: Edit only the ABOVE values instead.
# You may modify the config file itself if you have already one.
#

# Only called if $TOOLCHAIN_CONFIG not found or first run
generate_config ()
{
	touch "${TOOLCHAIN_CONFIG}"

	printf "# Automatically generated by NTU's toolchain builder
# Please use care when modifying this file
# All paths must be absolute! \n
CORES=%s\n
TOOLCHAIN_SRCDIR=%s
TOOLCHAIN_BINDIR=%s
TOOLCHAIN_PATCHDIR=%s\n
LINUX_VER=%s\n
GMP_VER=%s
MPFR_VER=%s
MPC_VER=%s
ISL_VER=%s\n" "${CORES}" "${TOOLCHAIN_SRCDIR}" "${TOOLCHAIN_BINDIR}" "${TOOLCHAIN_PATCHDIR}" \
"${LINUX_VER}" "${GMP_VER}" "${MPFR_VER}" "${MPC_VER}" "${ISL_VER}" &> "${TOOLCHAIN_CONFIG}"
}

#
# End of editing notice
#

# Load config if present, generate if not
printf "\n\tChecking for pre-existing config file...\n"
if [[ -f "${TOOLCHAIN_CONFIG}" ]] ; then
	printf "\tConfig file found. Loading...\n"
	# shellcheck source=/dev/null
	source "${TOOLCHAIN_CONFIG}"
	printf "\tLoaded.\n"
else
	printf "\tConfig file not found. Creating one.\n"
	generate_config
fi

#
# Environmental sanity checks
#

sanity_check()
{
# Redirect stdout (1) and stderr (2) to /dev/null (keep quiet)
# print error if type fails and exit with >0 exit status
if [[ ${SYSTEM_OK} == 1 ]] ; then
	printf "\n\tSystem already checked for prerequisites, all ok.\n"
else
	printf "\n\tChecking system for prerequisites...\n"

	type make > /dev/null 2>&1 || \
	{
		printf "\tCannot find make. Exiting.\n" ; exit 1 ;
	}

	type gcc > /dev/null 2>&1 || \
	{
		printf "\tCannot find GCC. Exiting.\n" ; exit 1 ;
	}

	type g++ > /dev/null 2>&1 || \
	{
		printf "\tCannot find G++. Exiting.\n" ; exit 1 ;
	}

	type ld > /dev/null 2>&1 || \
	{
		printf "\tPlease install Binutils. Exiting.\n" ; exit 1 ;
	}

	type libtool > /dev/null 2>&1 || \
	{
		printf "\tCannot find libtool. Exiting.\n" ; exit 1 ;
	}

	type wget > /dev/null 2>&1 || \
	{
		printf "\tCannot find wget. Exiting.\n" ; exit 1 ;
	}

	type git > /dev/null 2>&1 || \
	{
		printf "\tCannot find git. Exiting.\n" ; exit 1 ;
	}

	type patch > /dev/null 2>&1 || \
	{
		printf "\tCannot find patch. Exiting.\n" ; exit 1 ;
	}

	type autoconf > /dev/null 2>&1 || \
	{
		printf "\tCannot find autoconf. Exiting.\n" ; exit 1 ;
	}

	type automake > /dev/null 2>&1 || \
	{
		printf "\tCannot find automake. Exiting.\n" ; exit 1 ;
	}

	type grep > /dev/null 2>&1 || \
	{
		printf "\tCannot find grep. Exiting.\n" ; exit 1 ;
	}

	type gawk > /dev/null 2>&1 || \
	{
		printf "\tCannot find gawk. Exiting.\n" ; exit 1 ;
	}

	type sed > /dev/null 2>&1 || \
	{
		printf "\tCannot find sed. Exiting.\n" ; exit 1 ;
	}

	type m4 > /dev/null 2>&1 || \
	{
		printf "\tCannot find m4. Exiting.\n" ; exit 1 ;
	}

	printf "\tObvious required tools found.
\tChecking git version...\n"

	# Lexicographical order workaround
	#
	# Example:
	#
	# ---cut here---
	#!/usr/bin/env bash
	#string=1.2.3
	#string2=1.10.3
	#printf "\tIs %s greater than %s?\n" "${string}" "${string2}"
	#if [[ "${string}" > "${string2}" ]] ; then
	#	printf "\t%s is greater than %s.\n" "${string}" "${string2}"
	#else
	#	printf "\t%s is greater than %s.\n" "${string2}" "${string}"
	#fi
	#---cut here---
	#
	# This method below avoids the potential problem (depending on locale)
	# of $string being possibly greater than $string2
	#
	# print $3 means to print only the third set of characters
	# as git --version includes "git version" as part of the output.
	#
	# cut -d. means to remove (cut) decimals
	# cut -fX means to only select this field.
	# In this case, the fields are separated by a decimal (-d.)
	# but also includes output before the first decimal, hence print $3 is used
	# to avoid the first variable (GIT_VERSION_MAJOR) being "git version X"
	#
	GIT_VERSION=$(git --version | gawk '{print $3}')
	GIT_VERSION_MAJOR=$(printf "%s" "${GIT_VERSION}" | cut -d. -f1)
	GIT_VERSION_MINOR=$(printf "%s" "${GIT_VERSION}" | cut -d. -f2)
	GIT_VERSION_PATCH=$(printf "%s" "${GIT_VERSION}" | cut -d. -f3)

	if [[ "${GIT_VERSION_MAJOR}" -ge 1 ]] ; then
		if [[ "${GIT_VERSION_MINOR}" -ge 8 ]] ; then
			printf "\tGit 1.8 or newer.\n"
		elif [[ "${GIT_VERSION_MINOR}" -eq 7 ]] ; then
			if [[ "${GIT_VERSION_PATCH}" -ge 10 ]] ; then
				printf "\tGit 1.7.10 or newer\n"
			elif [[ "${GIT_VERSION_PATCH}" -le 10 ]] ; then
					printf "\tGit needs to be 1.7.10 or newer. Exiting.\n"
					exit 1
			fi
		fi
	else
		printf "\tError detecting git version.%s" "${REPORT_BUG_EXIT}"
	fi

# Only x86/amd64 are supported due to GCC hard links
# See function check_ld_linker_path for more info
# I'm also not interested in testing this on other architectures
	printf "\n\tDetecting kernel bitness...\n"
	unset ARCH_UNAME
	ARCH_UNAME=$(uname -m)
	if [[ ${ARCH_UNAME} == *64 ]] ; then
		printf "\t64-bit\n"
	elif [[ ${ARCH_UNAME} == *86 ]] ; then
		printf "\t32-bit\n"
	else
		printf "\tUnable to detect bitness.
\tOnly x86 and amd64 platforms supported.\n"
		exit 1
	fi
	SYSTEM_OK=1
	printf "\nARCH_UNAME=%s\n" "${ARCH_UNAME}" >> "${TOOLCHAIN_CONFIG}"
	printf "\nSYSTEM_OK=%s" "${SYSTEM_OK}" >> "${TOOLCHAIN_CONFIG}"
fi

# Definitely not the best way to check, but it works
if [[ "${GENTOO_PASS}" == 1 || "${GENERIC_TRUE}" == 1 ]] ; then
	printf "\n\tSystem already passed compiler check.\n"
else
	unset GENTOO_PASS
	unset GENERIC_TRUE
	printf "\n\tIs this a Gentoo system?\n"
	if [[ $(ls /etc/env.d/gcc/config*) ]] ; then
		printf "\tYes. Testing the build environment...\n"
		GCC_ENV_CONF=$(cat /etc/env.d/gcc/config*)
		MAKE_PROFILE_TEST=$(ls -la /etc/portage/make.profile)
		if [[ "${GCC_ENV_CONF}" == *vanilla || "${MAKE_PROFILE_TEST}" != *hardened* ]] ; then
			printf "\tGood, vanilla toolchain.\n"
			GENTOO_PASS=1
			printf "\nGENTOO_PASS=%s\n" "${GENTOO_PASS}" >> "${TOOLCHAIN_CONFIG}"
		elif [[ "${MAKE_PROFILE_TEST}" == *hardened* ]] ; then
			printf "\tNot vanilla GCC, this may cause a GCC build failure
\tas -fPIC and potentially other CFLAGS are known to issues.
\tYou may comment the following line out at your own risk. If you do,
\tplease report your success, your feedback is greatly appreciated.\n"
			exit 1
		else
			printf "\tError detecting the build environment.%s" "${REPORT_BUG_EXIT}"
			exit 1
		fi
	else
		printf "\tNo, assuming working toolchain.\n"
		GENERIC_TRUE=1
		printf "\nGENERIC_TRUE=%s\n" "${GENERIC_TRUE}" >> "${TOOLCHAIN_CONFIG}"
	fi
fi

	printf "\n\tPerforming basic sanity checks on %s.\n" "${TOOLCHAIN_CONFIG}"
	if [[ -f "${TOOLCHAIN_CONFIG}" && -r "${TOOLCHAIN_CONFIG}" ]] ; then
		printf "\t%s is a regular file and readable.\n" "${TOOLCHAIN_CONFIG}"
		if [[ -n "${TOOLCHAIN_BINDIR}" ]] ; then
			printf "\tInstallation directory is defined.\n"
		else
			printf "\tInstallation directory is invalid or undefined. Exiting.\n"
			exit 1
		fi
	else
		printf "\tError processing config file.%s" "${REPORT_BUG_EXIT}"
		exit 1
	fi
	printf "\tAssuming everything else is ok.\n"
}

#
# End of sanity checks
#

# If complete toolchain already exists, do not clean
# If interrupted, always do a fresh restart
if [[ -d "${TOOLCHAIN_BINDIR}" && "${TOOLCHAIN_COMPLETE}" != 1 && "${DEVELOPER_MODE}" != 1 ]] ; then
	printf "\n\t%s found.
\tToolchain build hung up unexpectedly.\n
\tDeleting %s in 10 seconds.\n
\tThis action cannot be undone!
\tPress Control+C to cancel.
\t10.\n" "${TOOLCHAIN_BINDIR}" "${TOOLCHAIN_BINDIR}"
	sleep 1
	printf "\t9.\n"
	sleep 1
	printf "\t8.\n"
	sleep 1
	printf "\t7.\n"
	sleep 1
	printf "\t6.\n"
	sleep 1
	printf "\t5.\n"
	sleep 1
	printf "\t4.\n"
	sleep 1
	printf "\t3.\n"
	sleep 1
	printf "\t2.\n"
	sleep 1
	printf "\t1.\n"
	sleep 1
	printf "\tCleaning up...\n\n"
	rm -rf "${TOOLCHAIN_BINDIR}"
	printf "\tFinished. Please restart the script.\n"
	exit 0
elif [[ -d "${TOOLCHAIN_BINDIR}" && "${TOOLCHAIN_COMPLETE}" == 1 ]] ; then
	printf "\n\tToolchain already built.\n
\t%s and\n\t%s must be manually removed to proceed.
\tNothing to do. Exiting.\n" "${TOOLCHAIN_BINDIR}" "${TOOLCHAIN_CONFIG}"
	exit 0
fi

# unset in case set previously
unset CFLAGS
unset CXXFLAGS
unset LDFLAGS

unset LINUX_TOOLCHAIN_SRCDIR
unset BINUTILS_TOOLCHAIN_SRCDIR
unset GLIBC_TOOLCHAIN_SRCDIR
unset GCC_TOOLCHAIN_SRCDIR
unset GMP_TOOLCHAIN_SRCDIR
unset MPFR_TOOLCHAIN_SRCDIR
unset MPC_TOOLCHAIN_SRCDIR
unset ISL_TOOLCHAIN_SRCDIR

unset BINUTILS_GIT
unset GLIBC_GIT
unset GCC_GIT

unset BINUTILS_GIT_OPTS
unset GLIBC_GIT_OPTS
unset GCC_GIT_OPTS
unset WGET_OPTS

unset LINUX_LOC
unset GMP_LOC
unset MPFR_LOC
unset MPC_LOC
unset ISL_LOC
unset GCC_PIC_PATCH

#
# DO NOT MODIFY
#

BINUTILS_TOOLCHAIN_SRCDIR="${TOOLCHAIN_SRCDIR}/binutils"
GLIBC_TOOLCHAIN_SRCDIR="${TOOLCHAIN_SRCDIR}/glibc"
GCC_TOOLCHAIN_SRCDIR="${TOOLCHAIN_SRCDIR}/gcc"
GMP_TOOLCHAIN_SRCDIR="${TOOLCHAIN_SRCDIR}/gmp"
MPFR_TOOLCHAIN_SRCDIR="${TOOLCHAIN_SRCDIR}/mpfr"
MPC_TOOLCHAIN_SRCDIR="${TOOLCHAIN_SRCDIR}/mpc"
ISL_TOOLCHAIN_SRCDIR="${TOOLCHAIN_SRCDIR}/isl"

BINUTILS_GIT="git://sourceware.org/git/binutils-gdb.git"
GLIBC_GIT="git://sourceware.org/git/glibc.git"
GCC_GIT="git://gcc.gnu.org/git/gcc.git"

# Reduce bandwidth, speed up the cloning process
BINUTILS_GIT_OPTS=(--depth"="1 -b "${BINUTILS_GIT_BRANCH}" --single-branch)
GLIBC_GIT_OPTS=(--depth"="1 -b "${GLIBC_GIT_BRANCH}" --single-branch)
GCC_GIT_OPTS=(--depth"="1 -b "${GCC_GIT_BRANCH}" --single-branch)

LINUX_TOOLCHAIN_SRCDIR="${TOOLCHAIN_SRCDIR}/linux-${LINUX_VER}"
LINUX_LOC="https://cdn.kernel.org/pub/linux/kernel/v4.x/linux-${LINUX_VER}.tar.xz"

GMP_LOC="http://ftpmirror.gnu.org/gnu/gmp/gmp-${GMP_VER}.tar.xz"
MPFR_LOC="http://www.mpfr.org/mpfr-current/mpfr-${MPFR_VER}.tar.xz"
MPC_LOC="http://ftpmirror.gnu.org/gnu/mpc/mpc-${MPC_VER}.tar.gz"
ISL_LOC="http://isl.gforge.inria.fr/isl-${ISL_VER}.tar.xz"

# Fixes stupid, highly annoying and also fatal, libstdc++-v3 PIC compiling error
# They should really mainline this patch as static builds are currently broken
GCC_PIC_PATCH="${TOOLCHAIN_PATCHDIR}/gcc-libstdc-pic.patch"

#
# End of editing notice
#

#
# Fetch any required sources
#

fetch_sources ()
{
	cd "${TOOLCHAIN_SRCDIR}" || \
	{
		printf "\tError changing directory to %s.%s" \
		"${TOOLCHAIN_SRCDIR}" "${REPORT_BUG_EXIT}" ; exit 1 ;
	}

	printf "\n\tFetching sources if needed...\n"

	# Binutils sources
if [[ ! -d "${BINUTILS_TOOLCHAIN_SRCDIR}" ]] ; then
	printf "\n\tFetching Binutils via git...\n"
	git clone "${BINUTILS_GIT_OPTS[@]}" "${BINUTILS_GIT}" "${BINUTILS_TOOLCHAIN_SRCDIR}"
fi

	# GLIBC sources
if [[ ! -d "${GLIBC_TOOLCHAIN_SRCDIR}" ]] ; then
	printf "\n\tFetching GLIBC via git...\n"
	git clone "${GLIBC_GIT_OPTS[@]}" "${GLIBC_GIT}" "${GLIBC_TOOLCHAIN_SRCDIR}"
fi

	# GCC sources
if [[ ! -d "${GCC_TOOLCHAIN_SRCDIR}" ]] ; then
	printf "\n\tFetching GCC via git...\n"
	git clone "${GCC_GIT_OPTS[@]}" "${GCC_GIT}" "${GCC_TOOLCHAIN_SRCDIR}"
fi

	# Linux sources
if [[ ! -f "${TOOLCHAIN_SRCDIR}"/linux-"${LINUX_VER}".tar.xz ]] ; then
	printf "\n\tDownloading Linux sources via wget...\n"
	wget -c "${LINUX_LOC}" || \
	{
		printf "\tError downloading Linux-%s. Exiting.\n" \
		"${LINUX_VER}" ; exit 1 ;
	}
fi

	# GMP sources
if [[ ! -f "${TOOLCHAIN_SRCDIR}"/gmp-"${GMP_VER}".tar.xz ]] ; then
	printf "\tDownloading GMP via wget...\n"
	wget -c ${GMP_LOC} || \
	{
		printf "\tError downloading GMP-%s. Exiting.\n" \
		"${GMP_VER}" ; exit 1 ;
	}
fi

	# MPFR sources
if [[ ! -f "${TOOLCHAIN_SRCDIR}"/mpfr-"${MPFR_VER}".tar.xz ]] ; then
	printf "\tDownloading MPFR via wget...\n"
	wget -c ${MPFR_LOC} || \
	{
		printf "\tError downloading MPFR-%s. Exiting.\n" \
		"${MPFR_VER}" ; exit 1 ;
	}
fi

	# MPC sources
if [[ ! -f "${TOOLCHAIN_SRCDIR}"/mpc-"${MPC_VER}".tar.gz ]] ; then
	printf "\tDownloading MPC via wget...\n"
	wget -c ${MPC_LOC} || \
	{
		printf "\tError downloading MPC-%s.\n Exiting.\n" \
		"${MPC_VER}" ; exit 1 ;
	}
fi

	# ISL sources
if [[ ! -f "${TOOLCHAIN_SRCDIR}"/isl-"${ISL_VER}".tar.xz ]] ; then
	printf "\tDownloading ISL via wget...\n"
	wget -c ${ISL_LOC} || \
	{
		printf "\tError downloading ISL-%s.\n Exiting.\n" \
		"${ISL_VER}" ; exit 1 ;
	}
fi
}

#
# End of fetch sources
#

#
# Unpack any required sources
#

prepare_sources ()
{
	printf "\tUnpacking any sources if needed...\n"

if [[ ! -d "${LINUX_TOOLCHAIN_SRCDIR}" ]] ; then
	printf "\n\tDecompressing Linux sources...\n"
	tar xf "${TOOLCHAIN_SRCDIR}"/linux-"${LINUX_VER}".tar.xz -C "${TOOLCHAIN_SRCDIR}"
fi

if [[ ! -d "${GMP_TOOLCHAIN_SRCDIR}" ]] ; then
	printf "\n\tDecompressing GMP...\n"
	tar xf "${TOOLCHAIN_SRCDIR}"/gmp-"${GMP_VER}".tar.xz -C "${TOOLCHAIN_SRCDIR}"
	mv -v "${TOOLCHAIN_SRCDIR}"/gmp-"${GMP_VER}" "${GMP_TOOLCHAIN_SRCDIR}"
fi

if [[ ! -d "${MPFR_TOOLCHAIN_SRCDIR}" ]] ; then
	printf "\n\tDecompressing MPFR...\n"
	tar xf "${TOOLCHAIN_SRCDIR}"/mpfr-"${MPFR_VER}".tar.xz -C "${TOOLCHAIN_SRCDIR}"
	mv -v "${TOOLCHAIN_SRCDIR}"/mpfr-"${MPFR_VER}" "${MPFR_TOOLCHAIN_SRCDIR}"
fi

if [[ ! -d "${MPC_TOOLCHAIN_SRCDIR}" ]] ; then
	printf "\n\tDecompressing MPC...\n"
	tar zxf "${TOOLCHAIN_SRCDIR}"/mpc-"${MPC_VER}".tar.gz -C "${TOOLCHAIN_SRCDIR}"
	mv -v "${TOOLCHAIN_SRCDIR}"/mpc-"${MPC_VER}" "${MPC_TOOLCHAIN_SRCDIR}"
fi

if [[ ! -d "${ISL_TOOLCHAIN_SRCDIR}" ]] ; then
	printf "\n\tDecompressing ISL...\n"
	tar xf "${TOOLCHAIN_SRCDIR}"/isl-"${ISL_VER}".tar.xz -C "${TOOLCHAIN_SRCDIR}"
	mv -v "${TOOLCHAIN_SRCDIR}"/isl-"${ISL_VER}" "${ISL_TOOLCHAIN_SRCDIR}"
fi
}

#
# End of unpack sources
#

#
# Verify sources
#

verify_sources ()
{
	printf "\n\tVerifying sources...\n"

	test -d "${LINUX_TOOLCHAIN_SRCDIR}" || \
	{
		printf "\tUnexpected error: %s cannot be found.%s" \
		"${LINUX_TOOLCHAIN_SRCDIR}" "${REPORT_BUG_EXIT}" ; exit 1 ;
	}

	test -d "${GMP_TOOLCHAIN_SRCDIR}" || \
	{
		printf "\tUnexpected error: %s cannot be found.%s" \
		"${GMP_TOOLCHAIN_SRCDIR}" "${REPORT_BUG_EXIT}" ; exit 1 ;
	}

	test -d "${MPFR_TOOLCHAIN_SRCDIR}" || \
	{
		printf "\tUnexpected error: %s cannot be found.%s" \
		"${MPFR_TOOLCHAIN_SRCDIR}" "${REPORT_BUG_EXIT}" ; exit 1 ;
	}

	test -d "${MPC_TOOLCHAIN_SRCDIR}" || \
	{
		printf "\tUnexpected error: %s cannot be found.%s" \
		"${MPC_TOOLCHAIN_SRCDIR}" "${REPORT_BUG_EXIT}" ; exit 1 ;
	}

	test -d "${ISL_TOOLCHAIN_SRCDIR}" || \
	{
		printf "\tUnexpected error: %s cannot be found.%s" \
		"${ISL_TOOLCHAIN_SRCDIR}" "${REPORT_BUG_EXIT}" ; exit 1 ;
	}

	test -d "${BINUTILS_TOOLCHAIN_SRCDIR}" || \
	{
		printf "\tUnexpected error: %s cannot be found.%s" \
		"${BINUTILS_TOOLCHAIN_SRCDIR}" "${REPORT_BUG_EXIT}" ; exit 1 ;
	}

	test -d "${GLIBC_TOOLCHAIN_SRCDIR}" || \
	{
		printf "\tUnexpected error: %s cannot be found.%s" \
		"${GLIBC_TOOLCHAIN_SRCDIR}" "${REPORT_BUG_EXIT}" ; exit 1 ;
	}

	test -d "${GCC_TOOLCHAIN_SRCDIR}" || \
	{
		printf "\tUnexpected error: %s cannot be found.%s" \
		"${GCC_TOOLCHAIN_SRCDIR}" "${REPORT_BUG_EXIT}" ; exit 1 ;
	}

	printf "\tAll sources verified.\n"
}

#
# End of verify sources

#
# Update git repositories
#

# We only clone a single branch, so changing branches later will not work
# Always do a fresh reset
update_binutils ()
{
	printf "\n\tUpdating Binutils...\n"

	cd "${BINUTILS_TOOLCHAIN_SRCDIR}" || \
	{
		printf "\tError changing directory to %s.%s" \
		"${BINUTILS_TOOLCHAIN_SRCDIR}" "${REPORT_BUG_EXIT}" ; exit 1 ;
	}

	git reset --hard HEAD
	git checkout "${BINUTILS_GIT_BRANCH}"
	git pull
}

update_glibc ()
{
	printf "\n\tUpdating GLIBC...\n"

	cd "${GLIBC_TOOLCHAIN_SRCDIR}" || \
	{
		printf "\tError changing directory to %s.%s" \
		"${GLIBC_TOOLCHAIN_SRCDIR}" "${REPORT_BUG_EXIT}" ; exit 1 ;
	}

	git reset --hard HEAD
	git checkout "${GLIBC_GIT_BRANCH}"
	git pull
}

update_gcc ()
{
	printf "\n\tUpdating GCC...\n"

	cd "${GCC_TOOLCHAIN_SRCDIR}" || \
	{
		printf "\tError changing directory to %s.%s" \
		"${GCC_TOOLCHAIN_SRCDIR}" "${REPORT_BUG_EXIT}" ; exit 1 ;
	}

	git reset --hard HEAD
	git checkout "${GCC_GIT_BRANCH}"
	git pull
}

update_sources ()
{
if [[ -d "${BINUTILS_TOOLCHAIN_SRCDIR}" && -d "${GLIBC_TOOLCHAIN_SRCDIR}" && -d "${GCC_TOOLCHAIN_SRCDIR}" ]] ; then
	update_binutils
	update_glibc
	update_gcc
else
	printf "\n\tUnexpected error: Cannot find git sources.%s" "${REPORT_BUG_EXIT}"
	exit 1
fi
}

#
# End of update sources
#

init_toolchain_srcdir ()
{
	printf "\n\tCreating source work directory...\n"

	# In case of wonky config file, we always double check
	mkdir -p "${TOOLCHAIN_SRCDIR}" || \
	{
		printf "\tFailed to create %s. Exiting.\n" \
		"${TOOLCHAIN_SRCDIR}" ; exit 1 ;
	}

}

printf "\n\tChecking if %s exists...\n" "${TOOLCHAIN_SRCDIR}"
if [[ -d "${TOOLCHAIN_SRCDIR}" ]] ; then
	printf "\tIt does.\n"
else
	printf "\tIt does not, must be your first rodeo.\n
\tWelcome! I really hope this script works for you.
\tPlease report any bugs to the author of this program.\n"
	init_toolchain_srcdir
fi

main ()
{
	sanity_check

	fetch_sources

	prepare_sources

	verify_sources

	update_sources
}

#
# This is where the building starts
#

#
# Create lib64 and a lib symlink to it if 64-bit
#

prepare_libdir()
{
	printf "\n\tPreparing toolchain libdir...\n"
if [[ "${ARCH_UNAME}" == *64 ]] ; then
	if [[ ! -d "${TOOLCHAIN_BINDIR}"/usr/lib64 ]] ; then

		mkdir -p "${TOOLCHAIN_BINDIR}"/usr/lib64 || \
		{
			printf "\tError creating ${TOOLCHAIN_BINDIR}/usr/lib64.%s" "${REPORT_BUG_EXIT}" ; exit 1 ;
		}

		printf "\tSetting TOOLCHAIN_LIBDIR...\n"
		TOOLCHAIN_LIBDIR="${TOOLCHAIN_BINDIR}/usr/lib64"

		printf "\tCreating symlink...\n"
		ln -sfv "${TOOLCHAIN_BINDIR}"/usr/lib64 "${TOOLCHAIN_BINDIR}"/usr/lib
	fi
elif [[ ${ARCH_UNAME} == *86 ]] ; then
	if [[ ! -d ${TOOLCHAIN_BINDIR}/usr/lib ]] ; then

		mkdir -p "${TOOLCHAIN_BINDIR}"/usr/lib || \
		{
			printf "\tError creating ${TOOLCHAIN_BINDIR}/usr/lib.%s" "${REPORT_BUG_EXIT}" ; exit 1 ;
		}

		printf "\tSetting TOOLCHAIN_LIBDIR...\n"
		TOOLCHAIN_LIBDIR="${TOOLCHAIN_BINDIR}/usr/lib"
	fi
fi
}

#
# End of possible lib symlink to lib64
#

#
# Prepare Binutils
#

prepare_binutils ()
{
	printf "\n\tCopying required libraries to Binutils if needed.\n"
if [[ ! -d "${BINUTILS_TOOLCHAIN_SRCDIR}"/gmp ]] ; then
	printf "\tCopying GMP to Binutils...\n"

	cp -pr "${GMP_TOOLCHAIN_SRCDIR}" "${BINUTILS_TOOLCHAIN_SRCDIR}"/ || \
	{
		printf "\tError copying GMP to Binutils.%s" "${REPORT_BUG_EXIT}" ; exit 1 ;
	}
fi

if [[ ! -d ${BINUTILS_TOOLCHAIN_SRCDIR}/mpfr ]] ; then
	printf "\tCopying MPFR to Binutils...\n"

	cp -pr "${MPFR_TOOLCHAIN_SRCDIR}" "${BINUTILS_TOOLCHAIN_SRCDIR}"/ || \
	{
		printf "\tError copying MPFR to Binutils.%s" "${REPORT_BUG_EXIT}" ; exit 1 ;
	}
fi

if [[ ! -d ${BINUTILS_TOOLCHAIN_SRCDIR}/mpc ]] ; then
	printf "\tCopying MPC to Binutils...\n"

	cp -pr "${MPC_TOOLCHAIN_SRCDIR}" "${BINUTILS_TOOLCHAIN_SRCDIR}"/ || \
	{
		printf "\tError copying MPC to Binutils.%s" "${REPORT_BUG_EXIT}" ; exit 1 ;
	}
fi

if [[ ! -d ${BINUTILS_TOOLCHAIN_SRCDIR}/isl ]] ; then
	printf "\tCopying ISL to Binutils...\n"

	cp -pr "${ISL_TOOLCHAIN_SRCDIR}" "${BINUTILS_TOOLCHAIN_SRCDIR}"/ || \
	{
		printf "\tError copying ISL to Binutils.%s" "${REPORT_BUG_EXIT}" ; exit 1 ;
	}
fi
}

#
# End of Binutils preparation
#

#
# GLIBC hard code fix
#

# Suggestions welcome on a better way to do this (very ugly)
check_glibc_hardcode ()
{
	X86_64_LDCONFIG="${GLIBC_TOOLCHAIN_SRCDIR}/sysdeps/unix/sysv/linux/x86_64/ldconfig.h"

	printf "\n\tIs GLIBC hard coded?\n"

	# Change hard link from /{lib,lib64} to $TOOLCHAIN_LIBDIR
if [[ $(grep -c "${TOOLCHAIN_LIBDIR}" "${X86_64_LDCONFIG}") == 1 ]] ; then
	printf "\tYes. GLIBC hard code fix already applied.\n"
elif [[ $(grep -c "${TOOLCHAIN_LIBDIR}" "${X86_64_LDCONFIG}") == 0 ]] ; then
	printf "\tGLIBC hard code fix not applied, attempting to fix via sed...\n"

	sed "s#/lib/ld-linux.so.2#${TOOLCHAIN_LIBDIR}/ld-linux.so.2#g" -i "${X86_64_LDCONFIG}" || \
	{
		printf "\tApplying 32-bit hard code fix failed.%s" "${REPORT_BUG_EXIT}" ; exit 1 ;
	}

	sed "s#/lib64/ld-linux-x86-64.so.2#${TOOLCHAIN_LIBDIR}/ld-linux-x86-64.so.2#g" -i "${X86_64_LDCONFIG}" || \
	{
		printf "\tApplying 64-bit hard code fix failed.%s" "${REPORT_BUG_EXIT}" ; exit 1 ;
	}

	printf "\tGLIBC hard code fix now applied.\n"
else
	printf "\tError detecting if GLIBC is hard coded.%s" "${REPORT_BUG_EXIT}"
	exit 1
fi
}

#
# End of GLIBC hard code fix

#
# Prepare GCC
#

# Not a good way to check if GCC is patched
# May break with future GCC updates
# Works for now, suggestions welcome
# Fixes GCC bug #58638
check_gcc_pic_patch ()
{
	printf "\n\tChecking if gcc/libstdc++-v3 is already patched...\n"

	PIC_CONF_NUM="$(grep -c 'glibcxx_lt_pic_flag="-prefer-pic"' \
	"${GCC_TOOLCHAIN_SRCDIR}"/libstdc++-v3/configure)"

	PIC_CONF_AC_NUM="$(grep -c 'glibcxx_lt_pic_flag="-prefer-pic"' \
	"${GCC_TOOLCHAIN_SRCDIR}"/libstdc++-v3/configure.ac)"

if [[ ${PIC_CONF_NUM} == 1 && ${PIC_CONF_AC_NUM} == 1 ]] ; then
	printf "\tlibstdc++-v3 PIC patch not applied. Applying...\n"

	cd "${GLIBC_TOOLCHAIN_SRCDIR}" || \
	printf "\tError changing directory to %s.%s" \
	"${GLIBC_TOOLCHAIN_SRCDIR}" "${REPORT_BUG_EXIT}" \
	exit 1

	patch -p1 < "${GCC_PIC_PATCH}" || \
	{
		printf "\tlibstdc++-v3 PIC patch failed.%s" "${REPORT_BUG_EXIT}" ; exit 1 ;
	}

elif [[ "${PIC_CONF_NUM}" == 2 && "${PIC_CONF_AC_NUM}" == 2 ]] ; then
	printf "\tlibstdc++-v3 PIC patch already applied.\n"
else
	printf "\tgcc/libstdc++-v3 patch failed.%s" "${REPORT_BUG_EXIT}"
	exit 1
fi
}

# Suggestions welcome on a better way to do this (very ugly)
check_ld_linker_path ()
{
	GCC_CONF_32_H="${GCC_TOOLCHAIN_SRCDIR}/gcc/config/i386/linux.h"
	GCC_CONF_64_H="${GCC_TOOLCHAIN_SRCDIR}/gcc/config/i386/linux64.h"

	printf "\n\tIs GCC using the proper linker?\n"

	# This changes GCC's hard link from /lib/ld-linux-so.2 to $TOOLCHAIN_LIBDIR/ld-linux.so.2
if [[ $(grep -c "${TOOLCHAIN_LIBDIR}" "${GCC_CONF_32_H}") == 1 ]] ; then
	printf "\tYes. 32-bit GCC linker fix already applied.\n"
elif [[ $(grep -c "${TOOLCHAIN_LIBDIR}" "${GCC_CONF_32_H}") == 0 ]] ; then
	printf "\t32-bit GCC linker fix not applied, attempting to fix via sed...\n"

	sed "s#/lib/ld-linux.so.2#${TOOLCHAIN_LIBDIR}/ld-linux.so.2#g" -i "${GCC_CONF_32_H}" || \
	{
		printf "\tApplying 32-bit linker fix failed.%s" "${REPORT_BUG_EXIT}" ; exit 1 ;
	}

	printf "\t32-bit GCC linker fix now applied.\n"
else
	printf "\tError detecting if GCC is using proper linker.%s" "${REPORT_BUG_EXIT}"
	exit 1
fi

	# 64-bit hard link fix
	# This changes GCC's hard link from /lib/ld-linux-x86-64.so.2 to $TOOLCHAIN_LIBDIR/ld-linux-x86-64.so.2
if [[ $(grep -c "${TOOLCHAIN_LIBDIR}" "${GCC_CONF_64_H}") == 1 ]] ; then
	printf "\tYes. 64-bit GCC linker fix already applied.\n"
elif [[ $(grep -c "${TOOLCHAIN_LIBDIR}" "${GCC_CONF_64_H}") == 0 ]] ; then
	printf "\t64-bit GCC linker fix not applied, attempting to fix via sed...\n"

	sed "s#/lib64/ld-linux-x86-64.so.2#${TOOLCHAIN_LIBDIR}/ld-linux-x86-64.so.2#g" -i "${GCC_CONF_64_H}" || \
	{
		printf "\tApplying 64-bit linker fix failed.%s" "${REPORT_BUG_EXIT}" ; exit 1 ;
	}

	sed "s#/lib/ld-linux.so.2#${TOOLCHAIN_LIBDIR}/ld-linux.so.2#g" -i "${GCC_CONF_64_H}" || \
	{
		printf "\tApplying 64-bit linker fix failed.%s" "${REPORT_BUG_EXIT}" ; exit 1 ;
	}

	printf "\t64-bit GCC linker fix now applied.\n"
else
	printf "\tError detecting if GCC is using proper linker.%s" "${REPORT_BUG_EXIT}"
	exit 1
fi
}

prepare_gcc ()
{
	check_gcc_pic_patch
	check_ld_linker_path

	printf "\n\tCopying required libraries to GCC if needed.\n"
if [[ ! -d "${GCC_TOOLCHAIN_SRCDIR}"/gmp ]] ; then
	printf "\tCopying GMP to GCC...\n"

	cp -pr "${GMP_TOOLCHAIN_SRCDIR}" "${GCC_TOOLCHAIN_SRCDIR}"/ || \
	{
		printf "\tError copying GMP to GCC.%s" "${REPORT_BUG_EXIT}" ; exit 1 ;
	}
fi

if [[ ! -d "${GCC_TOOLCHAIN_SRCDIR}"/mpfr ]] ; then
	printf "\tCopying MPFR to GCC...\n"

	cp -pr "${MPFR_TOOLCHAIN_SRCDIR}" "${GCC_TOOLCHAIN_SRCDIR}"/ || \
	{
		printf "\tError copying MPFR to GCC.%s" "${REPORT_BUG_EXIT}" ; exit 1 ;
	}
fi

if [[ ! -d "${GCC_TOOLCHAIN_SRCDIR}"/mpc ]] ; then
	printf "\tCopying MPC to GCC...\n"

	cp -pr "${MPC_TOOLCHAIN_SRCDIR}" "${GCC_TOOLCHAIN_SRCDIR}"/ || \
	{
		printf "\tError copying MPC to GCC.%s" "${REPORT_BUG_EXIT}" ; exit 1 ;
	}
fi

if [[ ! -d "${GCC_TOOLCHAIN_SRCDIR}"/isl ]] ; then
	printf "\tCopying ISL to GCC...\n"

	cp -pr "${ISL_TOOLCHAIN_SRCDIR}" "${GCC_TOOLCHAIN_SRCDIR}"/ || \
	{
		printf "\tError copying ISL to GCC.%s" "${REPORT_BUG_EXIT}" ; exit 1 ;
	}
fi
}

#
# End of GCC preparation
#

#
# Linux kernel headers
#

# Always make sure headers are sanitized
install_linux_headers ()
{
	printf "\n\tInstalling kernel headers to %s...\n" "${TOOLCHAIN_BINDIR}"/usr/include
	sleep 1

	cd "${LINUX_TOOLCHAIN_SRCDIR}" || \
	{
		printf "\tError changing directory to %s.%s" \
		"${LINUX_TOOLCHAIN_SRCDIR}" "${REPORT_BUG_EXIT}" ; exit 1 ;
	}

	make mrproper

if [[ ! -d "${LINUX_TOOLCHAIN_SRCDIR}/DESTDIR" ]] ; then
	mkdir -p "${LINUX_TOOLCHAIN_SRCDIR}"/DESTDIR
else
	rm -rf "${LINUX_TOOLCHAIN_SRCDIR}"/DESTDIR/*
fi

	make INSTALL_HDR_PATH="${LINUX_TOOLCHAIN_SRCDIR}/DESTDIR" headers_install

	mkdir -p "${TOOLCHAIN_BINDIR}"/usr/include || \
	{
		printf "\tError creating %s/include. Exiting.\n" \
		"${TOOLCHAIN_BINDIR}" ; exit 1 ;
	}

	cp -pr "${LINUX_TOOLCHAIN_SRCDIR}"/DESTDIR/include/* "${TOOLCHAIN_BINDIR}"/usr/include/ || \
	{
		printf "\tError installing kernel headers. Exiting.\n" ; exit 1 ;
	}
}

#
# End of installation of kernel headers
#

#
# First pass of Binutils
#

first_pass_binutils ()
{
	printf "\n\tBuilding first pass Binutils...\n"
	sleep 1

	prepare_binutils

	if [[ -d "${BINUTILS_TOOLCHAIN_SRCDIR}"/build ]] ; then

		cd "${BINUTILS_TOOLCHAIN_SRCDIR}"/build || \
		{
			printf "\tError changing directory to %s.%s" \
			"${BINUTILS_TOOLCHAIN_SRCDIR}" "${REPORT_BUG_EXIT}" ; exit 1 ;
		}

		make distclean
		rm -rf "${BINUTILS_TOOLCHAIN_SRCDIR}"/build/*
	else
		mkdir -p "${BINUTILS_TOOLCHAIN_SRCDIR}"/build || \
		{
			printf "\tError creating %s.%s" \
			"${BINUTILS_TOOLCHAIN_SRCDIR}"/build "${REPORT_BUG_EXIT}" ; exit 1 ;
		}

		cd "${BINUTILS_TOOLCHAIN_SRCDIR}"/build || \
		{
			printf "\tError changing directory to %s.%s" \
			"${BINUTILS_TOOLCHAIN_SRCDIR}"/build "${REPORT_BUG_EXIT}" ; exit 1 ;
		}
	fi

	../configure \
	--prefix="${TOOLCHAIN_BINDIR}"/usr \
	--libdir="${TOOLCHAIN_LIBDIR}" \
	--enable-gold \
	--enable-lto \
	--with-isl \
	--disable-nls \
	--disable-gdb \
	--disable-werror \
	--disable-shared || \
	{
		printf "\n\tBinutils configure error. Exiting.\n" ; exit 1 ;
	}

	make -j"${CORES}" || \
	{
		printf "\n\tBinutils compile error. Exiting.\n" ; exit 1 ;
	}

	make install || \
	{
		printf "\n\tBinutils install error. Exiting.\n" ; exit 1 ;
	}
}

#
# End of Binutils first pass
#

#
# First pass of GLIBC GNU C library
#

first_pass_glibc ()
{
	printf "\n\tBuilding first pass GLIBC...\n"
	sleep 1

	if [[ -d "${GLIBC_TOOLCHAIN_SRCDIR}"/build ]] ; then

		cd "${GLIBC_TOOLCHAIN_SRCDIR}"/build || \
		{
			printf "\tError changing directory to %s.%s" \
			"${GLIBC_TOOLCHAIN_SRCDIR}" "${REPORT_BUG_EXIT}" ; exit 1 ;
		}
		exit 1

		make distclean
		rm -rf "${GLIBC_TOOLCHAIN_SRCDIR}"/build/*
	else
		mkdir -p "${GLIBC_TOOLCHAIN_SRCDIR}"/build || \
		{
			printf "\tError creating %s.%s" \
			"${GLIBC_TOOLCHAIN_SRCDIR}"/build "${REPORT_BUG_EXIT}" ; exit 1 ;
		}

		cd "${GLIBC_TOOLCHAIN_SRCDIR}"/build || \
		{
			printf "\tError changing directory to %s.%s" \
			"${GLIBC_TOOLCHAIN_SRCDIR}"/build "${REPORT_BUG_EXIT}" ; exit 1 ;
		}
	fi

	../configure \
	--prefix="${TOOLCHAIN_BINDIR}"/usr \
	--libdir="${TOOLCHAIN_LIBDIR}" \
	--with-binutils="${TOOLCHAIN_BINDIR}"/usr/bin \
	--with-headers="${TOOLCHAIN_BINDIR}"/usr/include || \
	{
		printf "\n\tGLIBC configure error. Exiting.\n" ; exit 1 ;
	}

	make -j"${CORES}" || \
	{
		printf "\n\tGLIBC compile error. Exiting.\n" ; exit 1 ;
	}

	make install || \
	{
		printf "\n\tGLIBC install error. Exiting.\n" ; exit 1 ;
	}
}

#
# End of GLIBC first pass
#

#
# First pass of GCC
#

first_pass_gcc ()
{
	printf "\n\tBuilding first pass C/C++ compiler...\n"
	sleep 1

	prepare_gcc

	if [[ -d "${GCC_TOOLCHAIN_SRCDIR}"/build ]] ; then

		cd "${GCC_TOOLCHAIN_SRCDIR}"/build || \
		{
			printf "\tError changing directory to %s.%s" \
			"${GCC_TOOLCHAIN_SRCDIR}" "${REPORT_BUG_EXIT}" ; exit 1 ;
		}
		exit 1

		make distclean
		rm -rf "${GCC_TOOLCHAIN_SRCDIR}"/build/*
	else
		mkdir -p "${GCC_TOOLCHAIN_SRCDIR}"/build || \
		{
			printf "\tError creating %s.%s" \
			"${GCC_TOOLCHAIN_SRCDIR}"/build "${REPORT_BUG_EXIT}" ; exit 1 ;
		}

		cd "${GCC_TOOLCHAIN_SRCDIR}"/build || \
		{
			printf "\tError changing directory to %s.%s" \
			"${GCC_TOOLCHAIN_SRCDIR}"/build "${REPORT_BUG_EXIT}" ; exit 1 ;
		}
	fi

	AR="${TOOLCHAIN_BINDIR}"/usr/bin/ar \
	AS="${TOOLCHAIN_BINDIR}"/usr/bin/as \
	LD="${TOOLCHAIN_BINDIR}"/usr/bin/ld \
	NM="${TOOLCHAIN_BINDIR}"/usr/bin/nm \
	OBJCOPY="${TOOLCHAIN_BINDIR}"/usr/bin/objcopy \
	OBJDUMP="${TOOLCHAIN_BINDIR}"/usr/bin/objdump \
	NM="${TOOLCHAIN_BINDIR}"/usr/bin/ld \
	RANLIB="${TOOLCHAIN_BINDIR}"/usr/bin/ranlib \
	READELF="${TOOLCHAIN_BINDIR}"/usr/bin/readelf \
	STRIP="${TOOLCHAIN_BINDIR}"/usr/bin/strip \
	AR_FOR_TARGET="${TOOLCHAIN_BINDIR}"/usr/bin/ar \
	AS_FOR_TARGET="${TOOLCHAIN_BINDIR}"/usr/bin/as \
	LD_FOR_TARGET="${TOOLCHAIN_BINDIR}"/usr/bin/ld \
	NM_FOR_TARGET="${TOOLCHAIN_BINDIR}"/usr/bin/nm \
	OBJCOPY_FOR_TARGET="${TOOLCHAIN_BINDIR}"/usr/bin/objcopy \
	OBJDUMP_FOR_TARGET="${TOOLCHAIN_BINDIR}"/usr/bin/objdump \
	NM_FOR_TARGET="${TOOLCHAIN_BINDIR}"/usr/bin/ld \
	RANLIB_FOR_TARGET="${TOOLCHAIN_BINDIR}"/usr/bin/ranlib \
	READELF_FOR_TARGET="${TOOLCHAIN_BINDIR}"/usr/bin/readelf \
	STRIP_FOR_TARGET="${TOOLCHAIN_BINDIR}"/usr/bin/strip \
	../configure \
	--prefix="${TOOLCHAIN_BINDIR}"/usr \
	--with-local-prefix="${TOOLCHAIN_BINDIR}"/usr \
	--with-native-system-header-dir="${TOOLCHAIN_BINDIR}"/usr/include \
	--libdir="${TOOLCHAIN_LIBDIR}" \
	--enable-languages=c,c++ \
	--enable-gold \
	--enable-lto \
	--with-isl \
	--disable-nls \
	--disable-libatomic \
	--disable-libgomp \
	--disable-libmpx \
	--disable-libquadmath \
	--disable-libssp \
	--disable-libvtv  \
	--disable-libstdcxx-pch \
	--disable-libcilkrts \
	--disable-libitm \
	--disable-libsanitizer \
	--disable-multilib \
	--disable-werror \
	--disable-shared || \
	{
		printf "\n\tConfigure error. Exiting.\n" ; exit 1 ;
	}

	make -j"${CORES}" || \
	{
		printf "\n\tCompile error. Exiting.\n" ; exit 1 ;
	}

	make install || \
	{
		printf "\n\tInstall error. Exiting.\n" ; exit 1 ;
	}
}

#
# End of GCC first pass
#

#
# Second pass of Binutils
#

second_pass_binutils ()
{
	printf "\n\tBuilding second pass Binutils...\n"
	sleep 1

	prepare_binutils

	if [[ -d "${BINUTILS_TOOLCHAIN_SRCDIR}"/build ]] ; then

		cd "${BINUTILS_TOOLCHAIN_SRCDIR}"/build || \
		{
			printf "\tError changing directory to %s.%s" \
			"${BINUTILS_TOOLCHAIN_SRCDIR}" "${REPORT_BUG_EXIT}" ; exit 1 ;
		}
		exit 1

		make distclean
		rm -rf "${BINUTILS_TOOLCHAIN_SRCDIR}"/build/*
	else
		mkdir -p "${BINUTILS_TOOLCHAIN_SRCDIR}"/build || \
		{
			printf "\tError creating %s.%s" \
			"${BINUTILS_TOOLCHAIN_SRCDIR}"/build "${REPORT_BUG_EXIT}" ; exit 1 ;
		}

		cd "${BINUTILS_TOOLCHAIN_SRCDIR}"/build || \
		{
			printf "\tError changing directory to %s.%s" \
			"${BINUTILS_TOOLCHAIN_SRCDIR}"/build "${REPORT_BUG_EXIT}" ; exit 1 ;
		}
	fi

	# Eliminates the need for 500 lines here
	printf "\n\tUpdating PATH var...\n"
	unset ORIG_PATH
	unset NEW_PATH
	ORIG_PATH="$PATH"
	NEW_PATH="${TOOLCHAIN_BINDIR}/usr/bin:$PATH"
	PATH="${NEW_PATH}"
	printf "\tPATH now has new toolchain set first.\n"

	# --with-build-sysroot prevents linking to /usr
	# Not needed with GCC, already links to libs in ${TOOLCHAIN_LIBDIR}
	# Verified with ldd
	../configure \
	--with-build-sysroot="${TOOLCHAIN_BINDIR}" \
	--prefix="${TOOLCHAIN_BINDIR}"/usr \
	--libdir="${TOOLCHAIN_LIBDIR}" \
	--enable-gold \
	--enable-lto \
	--with-isl \
	--disable-gdb \
	--disable-werror \
	--disable-shared || \
	{
		printf "\n\tBinutils configure error. Exiting.\n" ; exit 1 ;
	}

	make -j"${CORES}" || \
	{
		printf "\n\tBinutils compile error. Exiting.\n" ; exit 1 ;
	}

	make install || \
	{
		printf "\n\tBinutils install error. Exiting.\n" ; exit 1 ;
	}
}

#
# End of Binutils second pass
#

#
# Second pass of GLIBC GNU C library
#

# FIXME: Still uses some /usr libs (chroot env may be only fix)
second_pass_glibc ()
{
	printf "\n\tBuilding second pass GLIBC...\n"
	sleep 1

	check_glibc_hardcode

	if [[ -d "${GLIBC_TOOLCHAIN_SRCDIR}"/build ]] ; then

		cd "${GLIBC_TOOLCHAIN_SRCDIR}"/build || \
		{
			printf "\tError changing directory to %s.%s" \
			"${GLIBC_TOOLCHAIN_SRCDIR}" "${REPORT_BUG_EXIT}" ; exit 1 ;
		}

		make distclean
		rm -rf "${GLIBC_TOOLCHAIN_SRCDIR}"/build/*
	else
		mkdir -p "${GLIBC_TOOLCHAIN_SRCDIR}"/build || \
		{
			printf "\tError creating %s.%s" \
			"${GLIBC_TOOLCHAIN_SRCDIR}"/build "${REPORT_BUG_EXIT}" ; exit 1 ;
		}

		cd "${GLIBC_TOOLCHAIN_SRCDIR}"/build || \
		{
			printf "\tError changing directory to %s.%s" \
			"${GLIBC_TOOLCHAIN_SRCDIR}"/build "${REPORT_BUG_EXIT}" ; exit 1 ;
		}
	fi

	# Half of these libraries still use /usr
	../configure \
	--prefix="${TOOLCHAIN_BINDIR}"/usr \
	--libdir="${TOOLCHAIN_LIBDIR}" \
	--with-headers="${TOOLCHAIN_BINDIR}"/usr/include || \
	{
		printf "\n\tGLIBC configure error. Exiting.\n" ; exit 1 ;
	}

	make -j"${CORES}" || \
	{
		printf "\n\tGLIBC compile error. Exiting.\n" ; exit 1 ;
	}

	make install || \
	{
		printf "\n\tGLIBC install error. Exiting.\n" ; exit 1 ;
	}
}

#
# End of GLIBC second pass
#

#
# Second pass of GCC
#

second_pass_gcc ()
{
	printf "\n\tBuilding Second pass C/C++ compiler...\n"
	sleep 1

	prepare_gcc

	if [[ -d "${GCC_TOOLCHAIN_SRCDIR}"/build ]] ; then

		cd "${GCC_TOOLCHAIN_SRCDIR}"/build || \
		{
			printf "\tError changing directory to %s.%s" \
			"${GCC_TOOLCHAIN_SRCDIR}" "${REPORT_BUG_EXIT}" ; exit 1 ;
		}
		exit 1

		make distclean
		rm -rf "${GCC_TOOLCHAIN_SRCDIR}"/build/*
	else
		mkdir -p "${GCC_TOOLCHAIN_SRCDIR}"/build || \
		{
			printf "\tError creating %s.%s" \
			"${GCC_TOOLCHAIN_SRCDIR}"/build "${REPORT_BUG_EXIT}" ; exit 1 ;
		}

		cd "${GCC_TOOLCHAIN_SRCDIR}"/build || \
		{
			printf "\tError changing directory to %s.%s" \
			"${GCC_TOOLCHAIN_SRCDIR}"/build "${REPORT_BUG_EXIT}" ; exit 1 ;
		}
	fi

	# libmpx fails to build (for now at least anyway, forget exact error)
	# libsanitizer may fail to build as well, turning off to be safe
	../configure \
	--prefix="${TOOLCHAIN_BINDIR}"/usr \
	--with-local-prefix="${TOOLCHAIN_BINDIR}"/usr \
	--with-native-system-header-dir="${TOOLCHAIN_BINDIR}"/usr/include \
	--libdir="${TOOLCHAIN_LIBDIR}" \
	--enable-languages=c,c++ \
	--enable-gold \
	--enable-lto \
	--with-isl \
	--disable-libmpx \
	--disable-libsanitizer \
	--disable-multilib \
	--disable-shared || \
	{
		printf "\n\tConfigure error. Exiting.\n" ; exit 1 ;
	}

	make -j"${CORES}" || \
	{
		printf "\n\tCompile error. Exiting.\n" ; exit 1 ;
	}

	make install || \
	{
		printf "\n\tInstall error. Exiting.\n" ; exit 1 ;
	}
}

#
# End of GCC second pass
#

#
# Execute build
#

build_toolchain ()
{
	prepare_libdir

	install_linux_headers

	first_pass_binutils

	first_pass_glibc

	first_pass_gcc

	second_pass_binutils

	second_pass_glibc

	second_pass_gcc

	printf "\n\tToolchain built successfully! \n
\tTo add the toolchain to your PATH, simply run the following:
\texport PATH=%s/usr/bin:%s\n
\tThen to make sure your new toolchain is in use, run:
\t'ld --version' and 'gcc --version' without quotes.\n
\tIf you would like to use the Gold linker by default,
\tRun the following:
\tln -sfv %s/usr/bin/ld.gold %s/usr/bin/ld\n" \
	"${TOOLCHAIN_BINDIR}" "${ORIG_PATH}" "${TOOLCHAIN_BINDIR}" "${TOOLCHAIN_BINDIR}"

	TOOLCHAIN_COMPLETE=1
	printf "\nTOOLCHAIN_COMPLETE=%s\n" "${TOOLCHAIN_COMPLETE}" >> "${TOOLCHAIN_CONFIG}"
}

main

build_toolchain

exit 0

#EOF
