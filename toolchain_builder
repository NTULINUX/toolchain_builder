#!/usr/bin/env bash
#
# Copyright (C) 2016 Alec Ari <neotheuser@ymail.com>
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

# TODO: Finish Binutils 2nd
# TODO: Glibc 2nd
# TODO: GCC 2nd
# TODO: Possible long-term reach goal: Create a small chroot environment using git toolchain

# printf because this is a C program (not really, just don't like echo)
printf "	NTU's complete bleeding edge native x86/amd64 toolchain builder\n"
printf "	Copyright (C) 2016 Alec Ari\n\n"
sleep 3

# This is here to ensure we don't accidentally break something bad
printf "	Making sure we are not root...\n"
if [[ ${EUID} = 0 ]] ; then
	printf "	This script must not be run as root.\n"
	exit 1
else
	printf "	Not root. Good.\n"
fi

# Environment sanity
unset STARTDIR
STARTDIR="${PWD}"

if [[ -w "${STARTDIR}" ]] ; then
	printf "	User has write permissions to ${STARTDIR}\n"
else
	printf "	Please switch to a non-root writeable directory, such as home.\n"
	exit 1
fi

# NOTICE: A value of 1 to the config file means true,
# while 0 means false. This logic is similar to:
# i.e. #define X_Y_Z 1 (for true) therefor NOT a typo

# Reduce lengthly printf lines
REPORT_BUG_EXIT="\n\tPlease report bug to script maintainer.\n\tExiting.\n"

# Only called if $TOOLCHAIN_CONFIG not found or first run
# You may modify these before running this script to your liking
generate_defaults ()
{
	unset CORES
	unset TOOLCHAIN_SRCDIR
	unset TOOLCHAIN_BINDIR
	unset TOOLCHAIN_PATCHDIR
	unset LINUX_VER
	unset GMP_VER
	unset MPFR_VER
	unset ISL_VER
	unset GCC_GIT_BRANCH
	unset BINUTILS_GIT_BRANCH
	unset GLIBC_GIT_BRANCH

	CORES=`cat /proc/cpuinfo | grep processor | wc -l`
	TOOLCHAIN_SRCDIR="${STARTDIR}/toolchain-src"
	TOOLCHAIN_BINDIR="${STARTDIR}/toolchain-bin"
	TOOLCHAIN_PATCHDIR="${STARTDIR}/patches"
	LINUX_VER="4.8.10"
	GMP_VER="6.1.1"
	MPFR_VER="3.1.5"
	ISL_VER="0.17.1"
	GCC_GIT_BRANCH="master"
	BINUTILS_GIT_BRANCH="binutils-2_27-branch"
	GLIBC_GIT_BRANCH="release/2.24/master"

	printf "# Automatically generated by NTU's toolchain builder\n" &> ${TOOLCHAIN_CONFIG}
	printf "# Please use care when modifying this file\n" >> ${TOOLCHAIN_CONFIG}
	printf "# All paths must be absolute! \n" >> ${TOOLCHAIN_CONFIG}

#
# DO NOT MODIFY: Edit above values instead
#

printf "
CORES="$CORES"
TOOLCHAIN_SRCDIR="${TOOLCHAIN_SRCDIR}"
TOOLCHAIN_BINDIR="${TOOLCHAIN_BINDIR}"
TOOLCHAIN_PATCHDIR="${TOOLCHAIN_PATCHDIR}"\n
LINUX_VER="${LINUX_VER}"\n
GMP_VER="${GMP_VER}"
MPFR_VER="${MPFR_VER}"
ISL_VER="${ISL_VER}"\n
GCC_GIT_BRANCH="${GCC_GIT_BRANCH}"
BINUTILS_GIT_BRANCH="${BINUTILS_GIT_BRANCH}"
GLIBC_GIT_BRANCH="${GLIBC_GIT_BRANCH}"\n" >> ${TOOLCHAIN_CONFIG}

	source ${TOOLCHAIN_CONFIG}
}


# Load config if present, generate if not
unset TOOLCHAIN_CONFIG
TOOLCHAIN_CONFIG="${STARTDIR}/toolchain_builder.config"
printf "	Checking for pre-existing config file...\n"
if [[ -a "${TOOLCHAIN_CONFIG}" ]] ; then
	printf "	Config file found. Loading...\n"
	source ${TOOLCHAIN_CONFIG}
	printf "	Loaded.\n"
else
	printf "	Config file not found. Creating one.\n"
	touch ${TOOLCHAIN_CONFIG}
	generate_defaults
fi

# Redirect stdout (1) and stderr (2) to /dev/null (keep quiet)
# print error if type fails and exit with >0 exit status
if [[ ${SYSTEM_OK} == 1 ]] ; then
	printf "	System already checked for prerequisites, all ok.\n"
else
	printf "	Checking system for prerequisites...\n"
	type make > /dev/null 2>&1 || { printf "	Cannot find make. Exiting.\n" ; exit 1 ; }
	type gcc > /dev/null 2>&1 || { printf "	Cannot find GCC. Exiting.\n" ; exit 1 ; }
	type g++ > /dev/null 2>&1 || { printf "	Cannot find G++. Exiting.\n" ; exit 1 ; }
	type ld > /dev/null 2>&1 || { printf "	Please install Binutils. Exiting.\n" ; exit 1 ; }
	type libtool > /dev/null 2>&1 || { printf "	Cannot find libtool. Exiting.\n" ; exit 1 ; }
	type wget > /dev/null 2>&1 || { printf "	Cannot find wget. Exiting.\n" ; exit 1 ; }
	type git > /dev/null 2>&1 || { printf "	Cannot find git. Exiting.\n" ; exit 1 ; }
	type patch > /dev/null 2>&1 || { printf "	Cannot find patch. Exiting.\n" ; exit 1 ; }
	type autoconf > /dev/null 2>&1 || { printf "	Cannot find autoconf. Exiting.\n" ; exit 1 ; }
	type automake > /dev/null 2>&1 || { printf "	Cannot find automake. Exiting.\n" ; exit 1 ; }
	type grep > /dev/null 2>&1 || { printf "	Cannot find grep. Exiting.\n" ; exit 1 ; }
	type gawk > /dev/null 2>&1 || { printf "	Cannot find gawk. Exiting.\n" ; exit 1 ; }
	type sed > /dev/null 2>&1 || { printf "	Cannot find sed. Exiting.\n" ; exit 1 ; }
	printf "	Obvious required tools found.\n"

# Only x86/amd64 are supported due to GCC hard links
# See function check_ld_linker_path for more info
	printf "	Detecting kernel bitness...\n"
	unset ARCH_UNAME
	ARCH_UNAME=`uname -m`
	if [[ ${ARCH_UNAME} == *64 ]] ; then
		printf "	64-bit\n"
	elif [[ ${ARCH_UNAME} == *86 ]] ; then
		printf "	32-bit\n"
	else
		printf "	Unable to detect bitness.\n"
		printf "	Only x86 and amd64 platforms supported.\n"
		exit 1
	fi
	SYSTEM_OK=1
	printf "\nARCH_UNAME=${ARCH_UNAME}\n" >> ${TOOLCHAIN_CONFIG}
	printf "\nSYSTEM_OK="${SYSTEM_OK}"\n" >> ${TOOLCHAIN_CONFIG}
fi

# Probably not the BEST way to check, but it gets the job done
if [[ ${GENTOO_PASS} == 1 || ${GENERIC_TRUE} == 1 ]] ; then
	printf "	System already passed compiler check.\n"
else
	unset GENTOO_TRUE
	unset GENERIC_TRUE
	printf "	Is this a Gentoo system?\n"
	if [[ `ls /etc/env.d/gcc/config*` ]] ; then
		printf "	Yes.\n" && GENTOO_TRUE=1
	else
		printf "	No, assuming working toolchain.\n"
		GENERIC_TRUE=1
		printf "\nGENERIC_TRUE=${GENERIC_TRUE}\n" >> ${TOOLCHAIN_CONFIG}
	fi

	unset GENTOO_PASS
	if [[ ${GENTOO_TRUE} == 1 ]] ; then
		GCC_ENV_CONF="`cat /etc/env.d/gcc/config*`"
		if [[ ${GCC_ENV_CONF} == *vanilla && ${GENTOO_TRUE} == 1 ]] ; then
			printf "	Good, vanilla toolchain.\n"
			GENTOO_PASS=1
			printf "\nGENTOO_PASS=${GENTOO_PASS}\n" >> ${TOOLCHAIN_CONFIG}
		else
			printf "	Not vanilla GCC, this may cause a GCC build failure
	as -fPIC and potentially other CFLAGS are known to issues.
	You may comment the following line out at your own risk. If you do,
	please report your success, your feedback is greatly appreciated.\n"
		exit 1
		fi
	fi
fi


# unset in case set previously
unset CFLAGS
unset CXXFLAGS
unset LDFLAGS

unset LINUX_TOOLCHAIN_SRCDIR
unset BINUTILS_TOOLCHAIN_SRCDIR
unset GLIBC_TOOLCHAIN_SRCDIR
unset GCC_TOOLCHAIN_SRCDIR
unset GMP_TOOLCHAIN_SRCDIR
unset MPFR_TOOLCHAIN_SRCDIR
unset MPC_TOOLCHAIN_SRCDIR
unset ISL_TOOLCHAIN_SRCDIR

unset BINUTILS_GIT
unset GLIBC_GIT
unset GCC_GIT

unset LINUX_LOC
unset GMP_LOC
unset MPFR_LOC
unset MPC_LOC
unset ISL_LOC
unset GCC_PIC_PATCH

#
# DO NOT MODIFY: Edit the config file instead
#

BINUTILS_TOOLCHAIN_SRCDIR="${TOOLCHAIN_SRCDIR}/binutils-gdb"
GLIBC_TOOLCHAIN_SRCDIR="${TOOLCHAIN_SRCDIR}/glibc"
GCC_TOOLCHAIN_SRCDIR="${TOOLCHAIN_SRCDIR}/gcc"
GMP_TOOLCHAIN_SRCDIR="${TOOLCHAIN_SRCDIR}/gmp"
MPFR_TOOLCHAIN_SRCDIR="${TOOLCHAIN_SRCDIR}/mpfr"
MPC_TOOLCHAIN_SRCDIR="${TOOLCHAIN_SRCDIR}/mpc"
ISL_TOOLCHAIN_SRCDIR="${TOOLCHAIN_SRCDIR}/isl"

BINUTILS_GIT="git://sourceware.org/git/binutils-gdb.git"
GLIBC_GIT="git://sourceware.org/git/glibc.git"
GCC_GIT="git://gcc.gnu.org/git/gcc.git"

LINUX_TOOLCHAIN_SRCDIR="${TOOLCHAIN_SRCDIR}/linux-${LINUX_VER}"
LINUX_LOC="https://cdn.kernel.org/pub/linux/kernel/v4.x/linux-${LINUX_VER}.tar.xz"

GMP_LOC="https://ftp.gnu.org/gnu/gmp/gmp-${GMP_VER}.tar.xz"
MPFR_LOC="http://www.mpfr.org/mpfr-current/mpfr-${MPFR_VER}.tar.xz"
MPC_LOC="ftp://ftp.gnu.org/gnu/mpc/mpc-${MPC_VER}.tar.gz"
ISL_LOC="http://isl.gforge.inria.fr/isl-${ISL_VER}.tar.xz"

# Fixes stupid, highly annoying and also fatal, libstdc++-v3 PIC compiling error
# They should really mainline this patch as static builds are currently broken
GCC_PIC_PATCH="${TOOLCHAIN_PATCHDIR}/gcc-libstdc-pic.patch"

#
# Fetch sources
#

# Only called if not there or first run
# if git: change this like the other fetch_* funcs
fetch_linux_headers ()
{
	printf "	Downloading Linux sources via wget...\n"

	wget -c ${LINUX_LOC} || \
	{ printf "	Error downloading Linux sources. Exiting.\n" ; exit 1 ; }

	printf "	Decompressing archive...\n"
	tar xf linux-${LINUX_VER}.tar.xz

	test -d ${LINUX_TOOLCHAIN_SRCDIR} || \
	{ printf "	Unexpected error: ${LINUX_TOOLCHAIN_SRCDIR} cannot be found. Exiting.\n" ; exit 1 ; }

}

# These are broken up in case some clone gets interrupted
fetch_binutils ()
{
	printf "	Fetching Binutils via git...\n"
	git clone ${BINUTILS_GIT}
if [[ -d "${BINUTILS_TOOLCHAIN_SRCDIR}" ]] ; then
	cd ${BINUTILS_TOOLCHAIN_SRCDIR}
	git checkout ${BINUTILS_GIT_BRANCH}
else
	printf "	Error cloning Binutils. Exiting.\n"
	exit 1
fi
}

fetch_glibc ()
{
	printf "	Fetching Glibc via git...\n"
	git clone ${GLIBC_GIT}
if [[ -d "${GLIBC_TOOLCHAIN_SRCDIR}" ]] ; then
	cd ${GLIBC_TOOLCHAIN_SRCDIR}
	git checkout ${GLIBC_GIT_BRANCH}
else
	printf "	Error cloning Glibc. Exiting.\n"
	exit 1
fi
}

fetch_gcc ()
{
	printf "	Fetching GCC via git...\n"
	git clone ${GCC_GIT}
if [[ -d "${GCC_TOOLCHAIN_SRCDIR}" ]] ; then
	cd ${GCC_TOOLCHAIN_SRCDIR}
	git checkout ${GCC_GIT_BRANCH}
else
	printf "	Error cloning GCC. Exiting.\n"
	exit 1
fi
}

fetch_gmp ()
{
	printf "	Downloading GMP via wget...\n"

	wget -c ${GMP_LOC} || \
	{ printf "	Error downloading GMP-${GMP_VER}. Exiting.\n" ; exit 1 ; }

	tar xf gmp-${GMP_VER}.tar.xz
	mv -v gmp-${GMP_VER} gmp

	test -d ${GMP_TOOLCHAIN_SRCDIR} || \
	{ printf "	Unexpected error: ${GMP_TOOLCHAIN_SRCDIR} cannot be found. Exiting.\n" ; exit 1 ; }

}

fetch_mpfr ()
{
	printf "	Downloading MPFR via wget...\n"

	wget -c ${MPFR_LOC} || \
	{ printf "	Error downloading MPFR-${MPFR_VER}. Exiting.\n" ; exit 1 ; }

	tar xf mpfr-${MPFR_VER}.tar.xz
	mv -v mpfr-${MPFR_VER} mpfr

	test -d ${MPFR_TOOLCHAIN_SRCDIR} || \
	{ printf "	Unexpected error: ${MPFR_TOOLCHAIN_SRCDIR} cannot be found. Exiting.\n" ; exit 1 ; }

}

fetch_mpc ()
{
	printf "	Downloading MPC via wget...\n"

	wget -c ${MPC_LOC} || \
	{ printf "	Error downloading MPC-${MPC_VER}.\n Exiting.\n" ; exit 1 ; }

	tar zxf mpc-${MPC_VER}.tar.gz
	mv -v mpc-${MPC_VER} mpc

	test -d ${MPC_TOOLCHAIN_SRCDIR} || \
	{ printf "	Unexpected error: ${MPC_TOOLCHAIN_SRCDIR} cannot be found. Exiting.\n" ; exit 1 ; }

}

fetch_isl ()
{
	printf "	Downloading ISL via wget...\n"

	wget -c ${ISL_LOC} || \
	{ printf "      Error downloading ISL-${ISL_VER}.\n Exiting.\n" ; exit 1 ; }

	tar xf isl-${ISL_VER}.tar.xz
	mv -v isl-${ISL_VER} isl

	test -d ${ISL_TOOLCHAIN_SRCDIR} || \
	{ printf "	Unexpected error: ${ISL_TOOLCHAIN_SRCDIR} cannot be found. Exiting.\n" ; exit 1 ; }

}

fetch_all ()
{
	fetch_linux_headers
	fetch_binutils
	fetch_gcc
	fetch_glibc
	fetch_gmp
	fetch_mpfr
	fetch_mpc
	fetch_isl
}

#
# End of fetch sources
#

#
# Update if present, fresh download if not
#

check_linux_srcdir ()
{
	printf "	Checking for ${LINUX_TOOLCHAIN_SRCDIR}...\n"
if [[ -d "${LINUX_TOOLCHAIN_SRCDIR}" ]] ; then
	printf "	Present.\n"
else
	printf "	Not found.\n"
	fetch_linux_headers
fi
}

check_binutils_srcdir ()
{
	printf "	Checking for Binutils git tree...\n"
if [[ -d "${BINUTILS_TOOLCHAIN_SRCDIR}" ]] ; then
	printf "	Directory exists, updating tree...\n"
	cd ${BINUTILS_TOOLCHAIN_SRCDIR}
	git pull
else
	printf "	Not found.\n"
	fetch_binutils
fi
}

check_glibc_srcdir ()
{
	printf "	Checking for Glibc git tree...\n"
if [[ -d "${GLIBC_TOOLCHAIN_SRCDIR}" ]] ; then
	printf "	Directory exists, updating tree...\n"
	cd ${GLIBC_TOOLCHAIN_SRCDIR}
	git pull
else
	printf "	Not found.\n"
	fetch_glibc
fi
}

check_gcc_srcdir ()
{
	printf "	Checking for GCC git tree...\n"
if [[ -d "${GCC_TOOLCHAIN_SRCDIR}" ]] ; then
	printf "	Directory exists, updating tree...\n"
	cd ${GCC_TOOLCHAIN_SRCDIR}
	# In case patch is applied, always reset tree to ensure git pull works
	git reset --hard HEAD
	git pull
else
	printf "	Not found.\n"
	fetch_gcc
fi
}

check_gmp_srcdir ()
{
	printf "	Checking for ${GMP_TOOLCHAIN_SRCDIR}...\n"
if [[ -d "${GMP_TOOLCHAIN_SRCDIR}" ]] ; then
	printf "	Present.\n"
else
	printf "	Not found.\n"
	fetch_gmp
fi
}

check_mpfr_srcdir ()
{
	printf "	Checking for ${MPFR_TOOLCHAIN_SRCDIR}...\n"
if [[ -d "${MPFR_TOOLCHAIN_SRCDIR}" ]] ; then
	printf "	Present.\n"
else
	printf "	Not found.\n"
	fetch_mpfr
fi
}

check_mpc_srcdir ()
{
	printf "	Checking for ${MPC_TOOLCHAIN_SRCDIR}...\n"
if [[ -d "${MPC_TOOLCHAIN_SRCDIR}" ]] ; then
	printf "	Present.\n"
else
	printf "	Not found.\n"
	fetch_mpc
fi
}

check_isl_srcdir ()
{
	printf "	Checking for ${ISL_TOOLCHAIN_SRCDIR}...\n"
if [[ -d "${ISL_TOOLCHAIN_SRCDIR}" ]] ; then
	printf "	Present.\n"
else
	printf "	Not found.\n"
	fetch_isl
fi
}

check_src ()
{
	check_linux_srcdir
	check_binutils_srcdir
	check_glibc_srcdir
	check_gcc_srcdir
	check_gmp_srcdir
	check_mpfr_srcdir
	check_mpc_srcdir
	check_isl_srcdir
}

#
# End of check sources
#

init_src ()
{
	printf "	Creating source work directory...\n"

	# In case of wonky config file, we always double check
	mkdir -p ${TOOLCHAIN_SRCDIR} || \
	{ printf "	Failed to create ${TOOLCHAIN_SRCDIR}. Exiting.\n" ; exit 1 ; }

	cd ${TOOLCHAIN_SRCDIR}
	fetch_all
}

printf "	Checking if ${TOOLCHAIN_SRCDIR} exists...\n"

if [[ -d "${TOOLCHAIN_SRCDIR}" ]] ; then
	printf "	It does.\n"
	cd ${TOOLCHAIN_SRCDIR}
	check_src
else
	printf "	It does not, must be a first run.\n"
	printf "	Welcome! I really hope this script works for you.\n"
	printf "	Please report any bugs to the author of this program.\n"
	init_src
fi

#
# This is where the building starts
#

# If complete toolchain already exists, do not clean
# If interrupted, always restart
# Will be updated when second pass is added
# Extra second added for read time
if [[ -d "${TOOLCHAIN_BINDIR}" && ${FIRST_PASS_GCC_SUCCESS} != 1 ]] ; then
	printf "	${TOOLCHAIN_BINDIR} found.\n\n"
	printf "	Toolchain build hung up unexpectedly.\n"
	printf "	Deleting ${TOOLCHAIN_BINDIR} in 5 seconds.\n"
	printf "	This action cannot be undone.\n"
	printf "	Press Control+C to cancel.\n"
	sleep 1
	printf "	5.\n"
	sleep 1
	printf "	4.\n"
	sleep 1
	printf "	3.\n"
	sleep 1
	printf "	2.\n"
	sleep 1
	printf "	1.\n"
	sleep 1
	printf "	Cleaning ${TOOLCHAIN_BINDIR}...\n"
	rm -rf ${TOOLCHAIN_BINDIR}
	printf "	${TOOLCHAIN_BINDIR} removed. Rebuilding toolchain...\n\n"
elif [[ -d "${TOOLCHAIN_BINDIR}" && ${FIRST_PASS_GCC_SUCCESS} == 1 ]] ; then
	printf "	Toolchain already built.\n"
	printf "	${TOOLCHAIN_BINDIR} must be removed manually to proceed.\n"
	printf "	Nothing to do. Exiting.\n"
	exit 0
fi

#
# Create lib64 with lib symlink if 64-bit
#

prepare_libdir()
{
if [[ ${ARCH_UNAME} == *64 ]] ; then
	if [[ ! -d ${TOOLCHAIN_BINDIR}/usr/lib64 ]] ; then

	mkdir -p ${TOOLCHAIN_BINDIR}/usr/lib64 || \
	{ printf "	Error creating ${TOOLCHAIN_BINDIR}/usr/lib64. Exiting.\n" ; exit 1 ; }

	TOOLCHAIN_LIBDIR="${TOOLCHAIN_BINDIR}/usr/lib64"
	printf "TOOLCHAIN_LIBDIR=${TOOLCHAIN_LIBDIR}" >> ${TOOLCHAIN_CONFIG}
	ln -sfv ${TOOLCHAIN_BINDIR}/usr/lib64 ${TOOLCHAIN_BINDIR}/usr/lib

	fi
elif [[ ${ARCH_UNAME} == *86 ]] ; then
	if [[ ! -d ${TOOLCHAIN_BINDIR}/usr/lib64 ]] ; then

	mkdir -p ${TOOLCHAIN_BINDIR}/usr/lib || \
	{ printf "	Error creating ${TOOLCHAIN_BINDIR}/usr/lib. Exiting.\n" ; exit 1 ; }

	TOOLCHAIN_LIBDIR="${TOOLCHAIN_BINDIR}/usr/lib"
	printf "TOOLCHAIN_LIBDIR=${TOOLCHAIN_LIBDIR}" >> ${TOOLCHAIN_CONFIG}

	fi
fi
}

#
# Linux kernel headers
#

# Always make sure headers are sanitized
install_linux_headers ()
{
	printf "	Installing kernel headers to ${TOOLCHAIN_BINDIR}/usr/include...\n"
	sleep 1

	cd ${LINUX_TOOLCHAIN_SRCDIR}
	make mrproper

if [[ ! -d "DESTDIR" ]] ; then
	mkdir -p DESTDIR
else
	rm -rf DESTDIR/*
fi

	make INSTALL_HDR_PATH="DESTDIR" headers_install

	mkdir -p ${TOOLCHAIN_BINDIR}/usr/include || \
	{ printf "	Error creating ${TOOLCHAIN_BINDIR}/include. Exiting.\n" ; exit 1 ; }

	cp -pr DESTDIR/include/* ${TOOLCHAIN_BINDIR}/usr/include/ || \
	{ printf "	Error installing kernel headers. Exiting.\n" ; exit 1 ; }
}

#
# Prepare Binutils
#

prepare_binutils ()
{
	printf "	Copying required libraries to Binutils if needed.\n"
if [[ ! -d ${BINUTILS_TOOLCHAIN_SRCDIR}/gmp ]] ; then
	printf "	Copying GMP to Binutils...\n"

	cp -pr {GMP_TOOLCHAIN_SRCDIR} ${BINUTILS_TOOLCHAIN_SRCDIR}/ || \
	printf "	Error copying GMP to Binutils.${REPORT_BUG_EXIT}"

elif [[ ! -d ${BINUTILS_TOOLCHAIN_SRCDIR}/mpfr ]] ; then
	printf "	Copying MPFR to Binutils...\n"

	cp -pr {MPFR_TOOLCHAIN_SRCDIR} ${BINUTILS_TOOLCHAIN_SRCDIR}/ || \
	printf "	Error copying MPFR to Binutils.${REPORT_BUG_EXIT}"

elif [[ ! -d ${BINUTILS_TOOLCHAIN_SRCDIR}/mpc ]] ; then
	printf "	Copying MPC to Binutils...\n"

	cp -pr {MPC_TOOLCHAIN_SRCDIR} ${BINUTILS_TOOLCHAIN_SRCDIR}/ || \
	printf "	Error copying MPC to Binutils.${REPORT_BUG_EXIT}"

elif [[ ! -d ${BINUTILS_TOOLCHAIN_SRCDIR}/isl ]] ; then
	printf "	Copying ISL to Binutils...\n"

	cp -pr {ISL_TOOLCHAIN_SRCDIR} ${BINUTILS_TOOLCHAIN_SRCDIR}/ || \
	printf "	Error copying ISL to Binutils.${REPORT_BUG_EXIT}"

else
	printf "	All libraries found.\n"
fi
}

#
# First pass of Binutils
#

first_pass_binutils ()
{
	printf "	Building first pass Binutils...\n"
	sleep 1

	prepare_binutils

	cd ${BINUTILS_TOOLCHAIN_SRCDIR}

if [[ ! -d "build" ]] ; then
	mkdir -p build
	cd build
else
	cd build
	make distclean
	rm -rf ${BINUTILS_TOOLCHAIN_SRCDIR}/build/*
fi

	../configure \
	--prefix=${TOOLCHAIN_BINDIR}/usr \
	--libdir=${TOOLCHAIN_LIBDIR} \
	--enable-gold \
	--enable-lto \
	--with-isl \
	--disable-nls \
	--disable-gdb \
	--disable-werror \
	--disable-shared || \
	{ printf "	Binutils configure error. Exiting.\n" ; exit 1 ; }

	make -j${CORES} || \
	{ printf "	Binutils compile error. Exiting.\n" ; exit 1 ; }
	make install || \
	{ printf "	Binutils install error. Exiting.\n" ; exit 1 ; }

	FIRST_PASS_BINUTILS_SUCCESS=1
	printf "\nFIRST_PASS_BINUTILS_SUCCESS=${FIRST_PASS_BINUTILS_SUCCESS}\n" >> ${TOOLCHAIN_CONFIG}
}

#
# First pass of Glibc GNU C library
#

first_pass_glibc ()
{
	printf "	Building first pass Glibc...\n"
	sleep 1

	cd ${GLIBC_TOOLCHAIN_SRCDIR}

if [[ ! -d "build" ]] ; then
	mkdir -p build
	cd build
else
	cd build
	make distclean
	rm -rf ${GLIBC_TOOLCHAIN_SRCDIR}/build/*
fi

	../configure \
	--prefix=${TOOLCHAIN_BINDIR}/usr \
	--libdir=${TOOLCHAIN_LIBDIR} \
	--with-binutils=${TOOLCHAIN_BINDIR}/usr/bin \
	--with-headers=${TOOLCHAIN_BINDIR}/usr/include || \
	{ printf "	Glibc configure error. Exiting.\n" ; exit 1 ; }

	make -j${CORES} || \
	{ printf "	Glibc compile error. Exiting.\n" ; exit 1 ; }

	make install || \
	{ printf "	Glibc install error. Exiting.\n" ; exit 1 ; }

	FIRST_PASS_GLIBC_SUCCESS=1
	printf "\nFIRST_PASS_GLIBC_SUCCESS=${FIRST_PASS_GLIBC_SUCCESS}\n" >> ${TOOLCHAIN_CONFIG}
}

#
# Prepare GCC
#

# Not the best way to check if GCC is patched
# May break with future GCC updates
# Works for now, suggestions welcome
# Fixes GCC bug #58638
check_gcc_pic_patch ()
{
	unset PIC_PATCH_APPLIED

	printf "	Checking if gcc/libstdc++-v3 is already patched...\n"

	PIC_CONF_NUM="$(grep 'glibcxx_lt_pic_flag="-prefer-pic"' \
	${GCC_TOOLCHAIN_SRCDIR}/libstdc++-v3/configure | wc -l)"

	PIC_CONF_AC_NUM="$(grep 'glibcxx_lt_pic_flag="-prefer-pic"' \
	${GCC_TOOLCHAIN_SRCDIR}/libstdc++-v3/configure.ac | wc -l)"

if [[ ${PIC_CONF_NUM} == 1 && ${PIC_CONF_AC_NUM} == 1 ]] ; then
	printf "	libstdc++-v3 PIC patch not applied. Applying...\n"
	cd ${GCC_TOOLCHAIN_SRCDIR}

	patch -p1 < ${GCC_PIC_PATCH} || \
	{ printf "	libstdc++-v3 PIC patch failed.${REPORT_BUG_EXIT}" ; exit 1 ; }

elif [[ ${PIC_CONF_NUM} == 2 && ${PIC_CONF_AC_NUM} == 2 ]] ; then
	printf "	libstdc++-v3 PIC patch already applied.\n"
else
	printf "	gcc/libstdc++-v3 patch failed.${REPORT_BUG_EXIT}"
	exit 1
fi
}

# Suggestions welcome on a better way to do this
check_ld_linker_path ()
{
	GCC_CONF_32_H="${GCC_TOOLCHAIN_SRCDIR}/gcc/config/i386/linux.h"
	GCC_CONF_64_H="${GCC_TOOLCHAIN_SRCDIR}/gcc/config/i386/linux64.h"

	printf "	Is GCC using the proper linker?\n"

	# 32-bit hard link fix
	# Change hard link from /lib/ld-linux-so.2 to $TOOLCHAIN_LIBDIR/ld-linux.so.2
	CHECK_HARDLINK_32=`grep "${TOOLCHAIN_LIBDIR}" ${GCC_CONF_32_H}`
if [[ $? == 0 ]] ; then
	printf "	Yes. 32-bit GCC linker fix already applied.\n"
elif [[ $? == 1 ]] ; then
	printf "	32-bit GCC linker fix not applied, attempting to fix via sed...\n"

	sed "s#/lib/ld-linux.so.2#${TOOLCHAIN_LIBDIR}/ld-linux.so.2#g" -i ${GCC_CONF_32_H} || \
	{ printf "	Applying 32-bit linker fix failed.${REPORT_BUG_EXIT}"; exit 1 ; }

	printf "	32-bit GCC linker fix now applied.\n"
else
	printf "	Error detecting if GCC is using proper linker.${REPORT_BUG_EXIT}\n"
	exit 1
fi

	# 64-bit hard link fix
	# Change hard link from /lib/ld-linux-x86-64.so.2 to $TOOLCHAIN_LIBDIR/ld-linux-x86-64.so.2
	CHECK_HARDLINK_64=`grep "${TOOLCHAIN_LIBDIR}" ${GCC_CONF_64_H}`
if [[ $? == 0 ]] ; then
	printf "	Yes. 64-bit GCC linker fix already applied.\n"
elif [[ $? == 1 ]] ; then
	printf "	64-bit GCC linker fix not applied, attempting to fix via sed...\n"

	sed "s#/lib64/ld-linux-x86-64.so.2#${TOOLCHAIN_LIBDIR}/ld-linux-x86-64.so.2#g" -i ${GCC_CONF_64_H} || \
	{ printf "	Applying 64-bit linker fix failed.${REPORT_BUG_EXIT}"; exit 1 ; }

	sed "s#/lib/ld-linux.so.2#${TOOLCHAIN_LIBDIR}/ld-linux.so.2#g" -i ${GCC_CONF_64_H} || \
	{ printf "	Applying 64-bit linker fix failed.${REPORT_BUG_EXIT}"; exit 1 ; }

	printf "	64-bit GCC linker fix now applied.\n"
else
	printf "	Error detecting if GCC is using proper linker.${REPORT_BUG_EXIT}\n"
	exit 1
fi
}

prepare_gcc ()
{
	check_gcc_pic_patch
	check_ld_linker_path

	printf "	Copying required libraries to GCC if needed.\n"
if [[ ! -d ${GCC_TOOLCHAIN_SRCDIR}/gmp ]] ; then
	printf "	Copying GMP to GCC...\n"

	cp -pr {GMP_TOOLCHAIN_SRCDIR} ${GCC_TOOLCHAIN_SRCDIR}/ || \
	printf "	Error copying GMP to GCC.${REPORT_BUG_EXIT}"

elif [[ ! -d ${GCC_TOOLCHAIN_SRCDIR}/mpfr ]] ; then
	printf "	Copying MPFR to GCC...\n"

	cp -pr {MPFR_TOOLCHAIN_SRCDIR} ${GCC_TOOLCHAIN_SRCDIR}/ || \
	printf "	Error copying MPFR to GCC.${REPORT_BUG_EXIT}"

elif [[ ! -d ${GCC_TOOLCHAIN_SRCDIR}/mpc ]] ; then
	printf "	Copying MPC to GCC...\n"

	cp -pr {MPC_TOOLCHAIN_SRCDIR} ${GCC_TOOLCHAIN_SRCDIR}/ || \
	printf "	Error copying MPC to GCC.${REPORT_BUG_EXIT}"

elif [[ ! -d ${GCC_TOOLCHAIN_SRCDIR}/isl ]] ; then
	printf "	Copying ISL to GCC...\n"

	cp -pr {ISL_TOOLCHAIN_SRCDIR} ${GCC_TOOLCHAIN_SRCDIR}/ || \
	printf "	Error copying ISL to GCC.${REPORT_BUG_EXIT}"

else
	printf "	All libraries found.\n"
fi
}

#
# End of GCC preparation
#

#
# First pass of GCC
#

first_pass_gcc ()
{
	printf "	Building first pass C/C++ compiler...\n"
	sleep 1

	prepare_gcc

	cd ${GCC_TOOLCHAIN_SRCDIR}

if [[ ! -d "build" ]] ; then
	mkdir -p build
	cd build
else
	cd build
	make distclean
	rm -rf ${GCC_TOOLCHAIN_SRCDIR}/build/*
fi

	AR=${TOOLCHAIN_BINDIR}/usr/bin/ar \
	AS=${TOOLCHAIN_BINDIR}/usr/bin/as \
	LD=${TOOLCHAIN_BINDIR}/usr/bin/ld \
	NM=${TOOLCHAIN_BINDIR}/usr/bin/nm \
	OBJCOPY=${TOOLCHAIN_BINDIR}/usr/bin/objcopy \
	OBJDUMP=${TOOLCHAIN_BINDIR}/usr/bin/objdump \
	NM=${TOOLCHAIN_BINDIR}/usr/bin/ld \
	RANLIB=${TOOLCHAIN_BINDIR}/usr/bin/ranlib \
	READELF=${TOOLCHAIN_BINDIR}/usr/bin/readelf \
	STRIP=${TOOLCHAIN_BINDIR}/usr/bin/strip \
	AR_FOR_TARGET=${TOOLCHAIN_BINDIR}/usr/bin/ar \
	AS_FOR_TARGET=${TOOLCHAIN_BINDIR}/usr/bin/as \
	LD_FOR_TARGET=${TOOLCHAIN_BINDIR}/usr/bin/ld \
	NM_FOR_TARGET=${TOOLCHAIN_BINDIR}/usr/bin/nm \
	OBJCOPY_FOR_TARGET=${TOOLCHAIN_BINDIR}/usr/bin/objcopy \
	OBJDUMP_FOR_TARGET=${TOOLCHAIN_BINDIR}/usr/bin/objdump \
	NM_FOR_TARGET=${TOOLCHAIN_BINDIR}/usr/bin/ld \
	RANLIB_FOR_TARGET=${TOOLCHAIN_BINDIR}/usr/bin/ranlib \
	READELF_FOR_TARGET=${TOOLCHAIN_BINDIR}/usr/bin/readelf \
	STRIP_FOR_TARGET=${TOOLCHAIN_BINDIR}/usr/bin/strip \
	../configure \
	--prefix=${TOOLCHAIN_BINDIR}/usr \
	--with-local-prefix=${TOOLCHAIN_BINDIR}/usr \
	--with-native-system-header-dir=${TOOLCHAIN_BINDIR}/usr/include \
	--libdir=${TOOLCHAIN_LIBDIR} \
	--enable-languages=c,c++ \
	--enable-gold \
	--enable-lto \
	--with-isl \
	--disable-nls \
	--disable-shared \
	--disable-multilib \
	--disable-libatomic \
	--disable-libgomp \
	--disable-libmpx \
	--disable-libquadmath \
	--disable-libssp \
	--disable-libvtv  \
	--disable-libstdcxx-pch \
	--disable-werror \
	--disable-libcilkrts \
	--disable-libitm \
	--disable-libsanitizer || \
	{ printf "	Configure error. Exiting.\n" ; exit 1 ; }

	make -j${CORES} || \
	{ printf "	Compile error. Exiting.\n" ; exit 1 ; }

	make install || \
	{ printf "	Install error. Exiting.\n" ; exit 1 ; }

	FIRST_PASS_GCC_SUCCESS=1
	printf "\nFIRST_PASS_GCC_SUCCESS=${FIRST_PASS_GCC_SUCCESS}\n" >> ${TOOLCHAIN_CONFIG}
}


# TODO: Finish second pass (Binutils, Glibc, GCC)
determine_pass_binutils ()
{
	first_pass_binutils

# TODO:
#if [[ ${FIRST_PASS_BINUTILS_SUCCESS} == 1 ]] ; then
#	second_pass_binutils
#elif [[ ${SECOND_PASS_BINUTILS_SUCCESS} == 1 ]] ; then
#	printf "	Second Binutils pass is built.\n"
#	printf "	Success! \n
#else
#	printf "	Unable to determine what Binutils stage to build.${REPORT_BUG_EXIT}"
#	exit 1
#fi
}

determine_pass_glibc ()
{
	first_pass_glibc

# TODO:
#if [[ ${FIRST_PASS_GLIBC_SUCCESS} == 1 ]] ; then
#	second_pass_glibc
#elif [[ ${SECOND_PASS_GLIBC_SUCCESS} == 1 ]] ; then
#	printf "	Second GLIBC pass is built.\n"
#	printf "	Success! \n"
#else
#	printf "	Unable to determine what Glibc stage to build.${REPORT_BUG_EXIT}"
#	exit 1
#fi
}

determine_pass_gcc ()
{
	first_pass_gcc

# TODO:
#if [[ ${FIRST_PASS_GCC_SUCCESS} == 1 ]] ; then
#	second_pass_gcc
#elif [[ ${SECOND_PASS_GCC_SUCCESS} == 1 ]] ; then
#	printf "	Second GCC is built.\n"
	printf "	Success!\n"
#else
#	printf "	Unable to determine what GCC stage to build.${REPORT_BUG_EXIT}"
#	exit 1
#fi
}

#
# End of build functions
#

#
# Execute build
#

prepare_libdir

install_linux_headers

determine_pass_binutils

determine_pass_glibc

determine_pass_gcc

exit 0
