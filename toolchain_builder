#!/usr/bin/env bash
#
# Copyright (C) 2016 - 2017 Alec Ari <neotheuser@ymail.com>
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

# TODO: Possible long-term reach goal: Create a small chroot environment using git toolchain
# May be necessary as GLIBC has hard codes set that I cannot find via git grep
# Gentoo prefix development team may have some answers

# printf because this is a C program (not really, just don't like echo)
printf "\n\tNTU's complete bleeding edge native x86/amd64 toolchain builder\n"
printf "\tCopyright (C) 2016 - 2017 Alec Ari\n"
sleep 3

# This is here to ensure we don't accidentally break something bad
printf "\n\tMaking sure we are not root...\n"
if [[ ${EUID} = 0 ]] ; then
	printf "\tThis script must not be run as root.\n"
	exit 1
else
	printf "\tNot root. Good.\n"
fi

# Environment sanity
unset STARTDIR
STARTDIR="${PWD}"

if [[ -w "${STARTDIR}" ]] ; then
	printf "\n\tUser has write permissions to ${STARTDIR}\n"
else
	printf "\n\tPlease switch to a non-root writeable directory, such as home.\n"
	exit 1
fi

# NOTICE: A value of 1 to the config file means true,
# while 0 means false. This logic is similar to:
# i.e. #define X_Y_Z 1 (for true) therefor NOT a typo

# Reduce lengthly printf lines
REPORT_BUG_EXIT="\n\tPlease report bug to script maintainer.\n\tExiting.\n"

# Only called if $TOOLCHAIN_CONFIG not found or first run
# You may modify these before running this script to your liking
generate_defaults ()
{
	unset CORES
	unset TOOLCHAIN_SRCDIR
	unset TOOLCHAIN_BINDIR
	unset TOOLCHAIN_PATCHDIR
	unset LINUX_VER
	unset GMP_VER
	unset MPFR_VER
	unset MPC_VER
	unset ISL_VER
	unset BINUTILS_GIT_BRANCH
	unset GLIBC_GIT_BRANCH
	unset GCC_GIT_BRANCH

	CORES=`cat /proc/cpuinfo | grep processor | wc -l`
	TOOLCHAIN_SRCDIR="${STARTDIR}/toolchain-src"
	TOOLCHAIN_BINDIR="${STARTDIR}/toolchain-bin"
	TOOLCHAIN_PATCHDIR="${STARTDIR}/patches"
	LINUX_VER="4.8.12"
	GMP_VER="6.1.1"
	MPFR_VER="3.1.5"
	MPC_VER="1.0.3"
	ISL_VER="0.17.1"
	BINUTILS_GIT_BRANCH="master"
	GLIBC_GIT_BRANCH="master"
	GCC_GIT_BRANCH="master"

	printf "# Automatically generated by NTU's toolchain builder\n" &> ${TOOLCHAIN_CONFIG}
	printf "# Please use care when modifying this file\n" >> ${TOOLCHAIN_CONFIG}
	printf "# All paths must be absolute! \n" >> ${TOOLCHAIN_CONFIG}

#
# DO NOT MODIFY: Edit above values instead
# or config file if this is not your first rodeo
#

printf "
CORES="$CORES"\n
TOOLCHAIN_SRCDIR="${TOOLCHAIN_SRCDIR}"
TOOLCHAIN_BINDIR="${TOOLCHAIN_BINDIR}"
TOOLCHAIN_PATCHDIR="${TOOLCHAIN_PATCHDIR}"\n
LINUX_VER="${LINUX_VER}"\n
GMP_VER="${GMP_VER}"
MPFR_VER="${MPFR_VER}"
MPC_VER="${MPC_VER}"
ISL_VER="${ISL_VER}"\n
BINUTILS_GIT_BRANCH="${BINUTILS_GIT_BRANCH}"
GLIBC_GIT_BRANCH="${GLIBC_GIT_BRANCH}"
GCC_GIT_BRANCH="${GCC_GIT_BRANCH}"\n" >> ${TOOLCHAIN_CONFIG}

	source ${TOOLCHAIN_CONFIG}
}

# Load config if present, generate if not
unset TOOLCHAIN_CONFIG
TOOLCHAIN_CONFIG="${STARTDIR}/toolchain_builder.config"
printf "\n\tChecking for pre-existing config file...\n"
if [[ -f "${TOOLCHAIN_CONFIG}" ]] ; then
	printf "\tConfig file found. Loading...\n"
	source ${TOOLCHAIN_CONFIG}
	printf "\tLoaded.\n"
else
	printf "\tConfig file not found. Creating one.\n"
	touch ${TOOLCHAIN_CONFIG}

	generate_defaults
fi

# Redirect stdout (1) and stderr (2) to /dev/null (keep quiet)
# print error if type fails and exit with >0 exit status
if [[ ${SYSTEM_OK} == 1 ]] ; then
	printf "\n\tSystem already checked for prerequisites, all ok.\n"
else
	printf "\n\tChecking system for prerequisites...\n"
	type make > /dev/null 2>&1 || { printf "\tCannot find make. Exiting.\n" ; exit 1 ; }
	type gcc > /dev/null 2>&1 || { printf "\tCannot find GCC. Exiting.\n" ; exit 1 ; }
	type g++ > /dev/null 2>&1 || { printf "\tCannot find G++. Exiting.\n" ; exit 1 ; }
	type ld > /dev/null 2>&1 || { printf "\tPlease install Binutils. Exiting.\n" ; exit 1 ; }
	type libtool > /dev/null 2>&1 || { printf "\tCannot find libtool. Exiting.\n" ; exit 1 ; }
	type wget > /dev/null 2>&1 || { printf "\tCannot find wget. Exiting.\n" ; exit 1 ; }
	type git > /dev/null 2>&1 || { printf "\tCannot find git. Exiting.\n" ; exit 1 ; }
	type patch > /dev/null 2>&1 || { printf "\tCannot find patch. Exiting.\n" ; exit 1 ; }
	type autoconf > /dev/null 2>&1 || { printf "\tCannot find autoconf. Exiting.\n" ; exit 1 ; }
	type automake > /dev/null 2>&1 || { printf "\tCannot find automake. Exiting.\n" ; exit 1 ; }
	type grep > /dev/null 2>&1 || { printf "\tCannot find grep. Exiting.\n" ; exit 1 ; }
	type gawk > /dev/null 2>&1 || { printf "\tCannot find gawk. Exiting.\n" ; exit 1 ; }
	type sed > /dev/null 2>&1 || { printf "\tCannot find sed. Exiting.\n" ; exit 1 ; }
	printf "\tObvious required tools found.\n"

# Only x86/amd64 are supported due to GCC hard links
# See function check_ld_linker_path for more info
	printf "\n\tDetecting kernel bitness...\n"
	unset ARCH_UNAME
	ARCH_UNAME=`uname -m`
	if [[ ${ARCH_UNAME} == *64 ]] ; then
		printf "\t64-bit\n"
	elif [[ ${ARCH_UNAME} == *86 ]] ; then
		printf "\t32-bit\n"
	else
		printf "\tUnable to detect bitness.\n"
		printf "\tOnly x86 and amd64 platforms supported.\n"
		exit 1
	fi
	SYSTEM_OK=1
	printf "\nARCH_UNAME=${ARCH_UNAME}\n" >> ${TOOLCHAIN_CONFIG}
	printf "\nSYSTEM_OK="${SYSTEM_OK}"\n" >> ${TOOLCHAIN_CONFIG}
fi

# Probably not the BEST way to check, but it gets the job done
if [[ ${GENTOO_PASS} == 1 || ${GENERIC_TRUE} == 1 ]] ; then
	printf "\n\tSystem already passed compiler check.\n"
else
	unset GENTOO_TRUE
	unset GENERIC_TRUE
	printf "\n\tIs this a Gentoo system?\n"
	if [[ `ls /etc/env.d/gcc/config*` ]] ; then
		printf "\tYes.\n" && GENTOO_TRUE=1
	else
		printf "\tNo, assuming working toolchain.\n"
		GENERIC_TRUE=1
		printf "\nGENERIC_TRUE=${GENERIC_TRUE}\n" >> ${TOOLCHAIN_CONFIG}
	fi

	unset GENTOO_PASS
	if [[ ${GENTOO_TRUE} == 1 ]] ; then
		GCC_ENV_CONF="`cat /etc/env.d/gcc/config*`"
		if [[ ${GCC_ENV_CONF} == *vanilla && ${GENTOO_TRUE} == 1 ]] ; then
			printf "\tGood, vanilla toolchain.\n"
			GENTOO_PASS=1
			printf "\nGENTOO_PASS=${GENTOO_PASS}\n" >> ${TOOLCHAIN_CONFIG}
		else
			printf "\tNot vanilla GCC, this may cause a GCC build failure
\tas -fPIC and potentially other CFLAGS are known to issues.
\tYou may comment the following line out at your own risk. If you do,
\tplease report your success, your feedback is greatly appreciated.\n"
		exit 1
		fi
	fi
fi

# If complete toolchain already exists, do not clean
# If interrupted, always restart
if [[ -d "${TOOLCHAIN_BINDIR}" && ${TOOLCHAIN_COMPLETE} != 1 && ${DEVELOPER_MODE} != 1 ]] ; then
	printf "\n\t${TOOLCHAIN_BINDIR} found.\n\n"
	printf "\tToolchain build hung up unexpectedly.\n"
	printf "\tDeleting ${TOOLCHAIN_BINDIR} and \n\t${TOOLCHAIN_CONFIG} in 10 seconds.\n\n"
	printf "\tThis action cannot be undone.\n"
	printf "\tPress Control+C to cancel.\n"
	printf "\t10.\n"
	sleep 1
	printf "\t9.\n"
	sleep 1
	printf "\t8.\n"
	sleep 1
	printf "\t7.\n"
	sleep 1
	printf "\t6.\n"
	sleep 1
	printf "\t5.\n"
	sleep 1
	printf "\t4.\n"
	sleep 1
	printf "\t3.\n"
	sleep 1
	printf "\t2.\n"
	sleep 1
	printf "\t1.\n"
	sleep 1
	printf "\tCleaning up...\n\n"
	rm -rf ${TOOLCHAIN_BINDIR}
	rm -rf ${TOOLCHAIN_CONFIG}
	printf "\tFinished. Please restart the script.\n"
	exit 0
elif [[ -d "${TOOLCHAIN_BINDIR}" && ${TOOLCHAIN_COMPLETE} == 1 ]] ; then
	printf "\n\tToolchain already built.\n"
	printf "\t${TOOLCHAIN_BINDIR} and\n\t${TOOLCHAIN_CONFIG} must be removed manually to proceed.\n"
	printf "\tNothing to do. Exiting.\n"
	exit 0
fi

# unset in case set previously
unset CFLAGS
unset CXXFLAGS
unset LDFLAGS

unset LINUX_TOOLCHAIN_SRCDIR
unset BINUTILS_TOOLCHAIN_SRCDIR
unset GLIBC_TOOLCHAIN_SRCDIR
unset GCC_TOOLCHAIN_SRCDIR
unset GMP_TOOLCHAIN_SRCDIR
unset MPFR_TOOLCHAIN_SRCDIR
unset MPC_TOOLCHAIN_SRCDIR
unset ISL_TOOLCHAIN_SRCDIR

unset BINUTILS_GIT
unset GLIBC_GIT
unset GCC_GIT

unset LINUX_LOC
unset GMP_LOC
unset MPFR_LOC
unset MPC_LOC
unset ISL_LOC
unset GCC_PIC_PATCH

#
# DO NOT MODIFY: Edit the config file instead
#

BINUTILS_TOOLCHAIN_SRCDIR="${TOOLCHAIN_SRCDIR}/binutils-gdb"
GLIBC_TOOLCHAIN_SRCDIR="${TOOLCHAIN_SRCDIR}/glibc"
GCC_TOOLCHAIN_SRCDIR="${TOOLCHAIN_SRCDIR}/gcc"
GMP_TOOLCHAIN_SRCDIR="${TOOLCHAIN_SRCDIR}/gmp"
MPFR_TOOLCHAIN_SRCDIR="${TOOLCHAIN_SRCDIR}/mpfr"
MPC_TOOLCHAIN_SRCDIR="${TOOLCHAIN_SRCDIR}/mpc"
ISL_TOOLCHAIN_SRCDIR="${TOOLCHAIN_SRCDIR}/isl"

BINUTILS_GIT="git://sourceware.org/git/binutils-gdb.git"
GLIBC_GIT="git://sourceware.org/git/glibc.git"
GCC_GIT="git://gcc.gnu.org/git/gcc.git"

LINUX_TOOLCHAIN_SRCDIR="${TOOLCHAIN_SRCDIR}/linux-${LINUX_VER}"
LINUX_LOC="https://cdn.kernel.org/pub/linux/kernel/v4.x/linux-${LINUX_VER}.tar.xz"

GMP_LOC="https://ftp.gnu.org/gnu/gmp/gmp-${GMP_VER}.tar.xz"
MPFR_LOC="http://www.mpfr.org/mpfr-current/mpfr-${MPFR_VER}.tar.xz"
MPC_LOC="ftp://ftp.gnu.org/gnu/mpc/mpc-${MPC_VER}.tar.gz"
ISL_LOC="http://isl.gforge.inria.fr/isl-${ISL_VER}.tar.xz"

# Fixes stupid, highly annoying and also fatal, libstdc++-v3 PIC compiling error
# They should really mainline this patch as static builds are currently broken
GCC_PIC_PATCH="${TOOLCHAIN_PATCHDIR}/gcc-libstdc-pic.patch"

#
# Fetch any required sources
#

fetch_sources ()
{
	cd ${TOOLCHAIN_SRCDIR}
	printf "\n\tFetching sources if needed...\n"

	# Binutils sources
if [[ ! -d "${BINUTILS_TOOLCHAIN_SRCDIR}" ]] ; then
	printf "\tFetching Binutils via git...\n"
	git clone ${BINUTILS_GIT}
fi

	# GLIBC sources
if [[ ! -d "${GLIBC_TOOLCHAIN_SRCDIR}" ]] ; then
	printf "\tFetching GLIBC via git...\n"
	git clone ${GLIBC_GIT}
fi

	# GCC sources
if [[ ! -d "${GCC_TOOLCHAIN_SRCDIR}" ]] ; then
	printf "\tFetching GCC via git...\n"
	git clone ${GCC_GIT}
fi

	# Linux sources
if [[ ! -f "${TOOLCHAIN_SRCDIR}/linux-${LINUX_VER}.tar.xz" ]] ; then
	printf "\tDownloading Linux sources via wget...\n"
	wget -c ${LINUX_LOC} || \
	{ printf "\tError downloading Linux sources. Exiting.\n" ; exit 1 ; }
fi

	# GMP sources
if [[ ! -f "${TOOLCHAIN_SRCDIR}/gmp-${GMP_VER}.tar.xz" ]] ; then
	printf "\tDownloading GMP via wget...\n"
	wget -c ${GMP_LOC} || \
	{ printf "\tError downloading GMP-${GMP_VER}. Exiting.\n" ; exit 1 ; }
fi

	# MPFR sources
if [[ ! -f "${TOOLCHAIN_SRCDIR}/mpfr-${MPFR_VER}.tar.xz" ]] ; then
	printf "\tDownloading MPFR via wget...\n"
	wget -c ${MPFR_LOC} || \
	{ printf "\tError downloading MPFR-${MPFR_VER}. Exiting.\n" ; exit 1 ; }
fi

	# MPC sources
if [[ ! -f "${TOOLCHAIN_SRCDIR}/mpc-${MPC_VER}.tar.gz" ]] ; then
	printf "\tDownloading MPC via wget...\n"
	wget -c ${MPC_LOC} || \
	{ printf "\tError downloading MPC-${MPC_VER}.\n Exiting.\n" ; exit 1 ; }
fi

	# ISL sources
if [[ ! -f "${TOOLCHAIN_SRCDIR}/isl-${ISL_VER}.tar.xz" ]] ; then
	printf "\tDownloading ISL via wget...\n"
	wget -c ${ISL_LOC} || \
	{ printf "\tError downloading ISL-${ISL_VER}.\n Exiting.\n" ; exit 1 ; }
fi
}

#
# End of fetch sources
#

#
# Unpack any required sources
#

prepare_sources ()
{
	printf "\n\tUnpacking any sources if needed...\n"

if [[ ! -d "${LINUX_TOOLCHAIN_SRCDIR}" ]] ; then
	printf "\tDecompressing Linux sources...\n"
	tar xf ${TOOLCHAIN_SRCDIR}/linux-${LINUX_VER}.tar.xz -C ${TOOLCHAIN_SRCDIR}
fi

if [[ ! -d "${GMP_TOOLCHAIN_SRCDIR}" ]] ; then
	printf "\tDecompressing GMP...\n"
	tar xf ${TOOLCHAIN_SRCDIR}/gmp-${GMP_VER}.tar.xz -C ${TOOLCHAIN_SRCDIR}
	mv -v ${TOOLCHAIN_SRCDIR}/gmp-${GMP_VER} ${GMP_TOOLCHAIN_SRCDIR}
fi

if [[ ! -d "${MPFR_TOOLCHAIN_SRCDIR}" ]] ; then
	printf "\tDecompressing MPFR...\n"
	tar xf ${TOOLCHAIN_SRCDIR}/mpfr-${MPFR_VER}.tar.xz -C ${TOOLCHAIN_SRCDIR}
	mv -v ${TOOLCHAIN_SRCDIR}/mpfr-${MPFR_VER} ${MPFR_TOOLCHAIN_SRCDIR}
fi

if [[ ! -d "${MPC_TOOLCHAIN_SRCDIR}" ]] ; then
	printf "\tDecompressing MPC...\n"
	tar zxf ${TOOLCHAIN_SRCDIR}/mpc-${MPC_VER}.tar.gz -C ${TOOLCHAIN_SRCDIR}
	mv -v ${TOOLCHAIN_SRCDIR}/mpc-${MPC_VER} ${MPC_TOOLCHAIN_SRCDIR}
fi

if [[ ! -d "${ISL_TOOLCHAIN_SRCDIR}" ]] ; then
	printf "\tDecompressing ISL...\n"
	tar xf ${TOOLCHAIN_SRCDIR}/isl-${ISL_VER}.tar.xz -C ${TOOLCHAIN_SRCDIR}
	mv -v ${TOOLCHAIN_SRCDIR}/isl-${ISL_VER} ${ISL_TOOLCHAIN_SRCDIR}
fi
}

#
# End of unpack sources
#

#
# Verify sources
#

verify_sources ()
{
	printf "\n\tVerifying sources...\n"

	test -d ${LINUX_TOOLCHAIN_SRCDIR} || \
	{ printf "\tUnexpected error: ${LINUX_TOOLCHAIN_SRCDIR} cannot be found.${REPORT_BUG_EXIT}" ; exit 1 ; }

	test -d ${GMP_TOOLCHAIN_SRCDIR} || \
	{ printf "\tUnexpected error: ${GMP_TOOLCHAIN_SRCDIR} cannot be found.${REPORT_BUG_EXIT}" ; exit 1 ; }

	test -d ${MPFR_TOOLCHAIN_SRCDIR} || \
	{ printf "\tUnexpected error: ${MPFR_TOOLCHAIN_SRCDIR} cannot be found.${REPORT_BUG_EXIT}" ; exit 1 ; }

	test -d ${MPC_TOOLCHAIN_SRCDIR} || \
	{ printf "\tUnexpected error: ${MPC_TOOLCHAIN_SRCDIR} cannot be found.${REPORT_BUG_EXIT}" ; exit 1 ; }

	test -d ${ISL_TOOLCHAIN_SRCDIR} || \
	{ printf "\tUnexpected error: ${ISL_TOOLCHAIN_SRCDIR} cannot be found.${REPORT_BUG_EXIT}" ; exit 1 ; }

	test -d ${BINUTILS_TOOLCHAIN_SRCDIR} || \
	{ printf "\tUnexpected error: ${BINUTILS_TOOLCHAIN_SRCDIR} cannot be found.${REPORT_BUG_EXIT}" ; exit 1 ; }

	test -d ${GLIBC_TOOLCHAIN_SRCDIR} || \
	{ printf "\tUnexpected error: ${GLIBC_TOOLCHAIN_SRCDIR} cannot be found.${REPORT_BUG_EXIT}" ; exit 1 ; }

	test -d ${GCC_TOOLCHAIN_SRCDIR} || \
	{ printf "\tUnexpected error: ${GCC_TOOLCHAIN_SRCDIR} cannot be found.${REPORT_BUG_EXIT}" ; exit 1 ; }

	printf "\tAll sources verified.\n"
}

#
# End of verify sources

#
# Update git repositories
#

# Have git pull run twice in case branches changed, sometimes pull needs another pass
# Reset source trees every time just in case we changed something
update_binutils ()
{
	printf "\n\tUpdating Binutils...\n"
	cd ${BINUTILS_TOOLCHAIN_SRCDIR}
	git reset --hard HEAD
	git pull
	git checkout ${BINUTILS_GIT_BRANCH}
	git pull
}

update_glibc ()
{
	printf "\n\tUpdating GLIBC...\n"
	cd ${GLIBC_TOOLCHAIN_SRCDIR}
	git reset --hard HEAD
	git pull
	git checkout ${GLIBC_GIT_BRANCH}
	git pull
}

update_gcc ()
{
	printf "\n\tUpdating GCC...\n"
	cd ${GCC_TOOLCHAIN_SRCDIR}
	git reset --hard HEAD
	git pull
	git checkout ${GCC_GIT_BRANCH}
	git pull
}

update_sources ()
{
if [[ -d ${BINUTILS_TOOLCHAIN_SRCDIR} && -d ${GLIBC_TOOLCHAIN_SRCDIR} && -d ${GCC_TOOLCHAIN_SRCDIR} ]] ; then
	update_binutils
	update_glibc
	update_gcc
else
	printf "\n\tUnexpected error: Cannot find git sources.${REPORT_BUG_EXIT}"
	exit 1
fi
}

#
# End of update sources
#

init_toolchain_srcdir ()
{
	printf "\n\tCreating source work directory...\n"

	# In case of wonky config file, we always double check
	mkdir -p ${TOOLCHAIN_SRCDIR} || \
	{ printf "\tFailed to create ${TOOLCHAIN_SRCDIR}. Exiting.\n" ; exit 1 ; }

}

printf "\n\tChecking if ${TOOLCHAIN_SRCDIR} exists...\n"
if [[ -d "${TOOLCHAIN_SRCDIR}" ]] ; then
	printf "\tIt does.\n"
else
	printf "\tIt does not, must be your first rodeo.\n"
	printf "\tWelcome! I really hope this script works for you.\n"
	printf "\tPlease report any bugs to the author of this program.\n"

	init_toolchain_srcdir
fi

fetch_sources

prepare_sources

verify_sources

update_sources

#
# This is where the building starts
#

#
# Create lib64 and a lib symlink to it if 64-bit
#

prepare_libdir()
{
	printf "\n\tPreparing toolchain libdir...\n"
if [[ ${ARCH_UNAME} == *64 ]] ; then
	if [[ ! -d ${TOOLCHAIN_BINDIR}/usr/lib64 ]] ; then

	mkdir -p ${TOOLCHAIN_BINDIR}/usr/lib64 || \
	{ printf "\tError creating ${TOOLCHAIN_BINDIR}/usr/lib64. Exiting.\n" ; exit 1 ; }

	printf "\tSetting TOOLCHAIN_LIBDIR...\n"
	TOOLCHAIN_LIBDIR="${TOOLCHAIN_BINDIR}/usr/lib64"
	printf "\nTOOLCHAIN_LIBDIR=${TOOLCHAIN_LIBDIR}\n" >> ${TOOLCHAIN_CONFIG}

	printf "\tCreating symlink...\n"
	ln -sfv ${TOOLCHAIN_BINDIR}/usr/lib64 ${TOOLCHAIN_BINDIR}/usr/lib

	LIBDIR_SET=1
	printf "LIBDIR_SET=${LIBDIR_SET}\n" >> ${TOOLCHAIN_CONFIG}
	fi
elif [[ ${ARCH_UNAME} == *86 ]] ; then
	if [[ ! -d ${TOOLCHAIN_BINDIR}/usr/lib64 ]] ; then

	mkdir -p ${TOOLCHAIN_BINDIR}/usr/lib || \
	{ printf "\tError creating ${TOOLCHAIN_BINDIR}/usr/lib. Exiting.\n" ; exit 1 ; }

	printf "\tSetting TOOLCHAIN_LIBDIR...\n"
	TOOLCHAIN_LIBDIR="${TOOLCHAIN_BINDIR}/usr/lib"
	printf "\nTOOLCHAIN_LIBDIR=${TOOLCHAIN_LIBDIR}\n" >> ${TOOLCHAIN_CONFIG}

	LIBDIR_SET=1
	printf "LIBDIR_SET=${LIBDIR_SET}\n" >> ${TOOLCHAIN_CONFIG}
	fi
fi
}

#
# End of possible lib symlink to lib64
#

#
# Prepare Binutils
#

prepare_binutils ()
{
	printf "\n\tCopying required libraries to Binutils if needed.\n"
if [[ ! -d ${BINUTILS_TOOLCHAIN_SRCDIR}/gmp ]] ; then
	printf "\tCopying GMP to Binutils...\n"

	cp -pr ${GMP_TOOLCHAIN_SRCDIR} ${BINUTILS_TOOLCHAIN_SRCDIR}/ || \
	{ printf "\tError copying GMP to Binutils.${REPORT_BUG_EXIT}" ; exit 1 ; }
fi

if [[ ! -d ${BINUTILS_TOOLCHAIN_SRCDIR}/mpfr ]] ; then
	printf "\tCopying MPFR to Binutils...\n"

	cp -pr ${MPFR_TOOLCHAIN_SRCDIR} ${BINUTILS_TOOLCHAIN_SRCDIR}/ || \
	{ printf "\tError copying MPFR to Binutils.${REPORT_BUG_EXIT}" ; exit 1 ; }
fi

if [[ ! -d ${BINUTILS_TOOLCHAIN_SRCDIR}/mpc ]] ; then
	printf "\tCopying MPC to Binutils...\n"

	cp -pr ${MPC_TOOLCHAIN_SRCDIR} ${BINUTILS_TOOLCHAIN_SRCDIR}/ || \
	{ printf "\tError copying MPC to Binutils.${REPORT_BUG_EXIT}" ; exit 1 ; }
fi

if [[ ! -d ${BINUTILS_TOOLCHAIN_SRCDIR}/isl ]] ; then
	printf "\tCopying ISL to Binutils...\n"

	cp -pr ${ISL_TOOLCHAIN_SRCDIR} ${BINUTILS_TOOLCHAIN_SRCDIR}/ || \
	{ printf "\tError copying ISL to Binutils.${REPORT_BUG_EXIT}" ; exit 1 ; }
fi
}

#
# End of Binutils preparation
#

#
# GLIBC hard code fix
#

# Suggestions welcome on a better way to do this
check_glibc_hardcode ()
{
	X86_64_LDCONFIG="${GLIBC_TOOLCHAIN_SRCDIR}/sysdeps/unix/sysv/linux/x86_64/ldconfig.h"

	printf "\n\tIs GLIBC hard coded?\n"

	# Change hard link from /{lib,lib64} to $TOOLCHAIN_LIBDIR
	CHECK_GLIBC_HARDLINK=`grep "${TOOLCHAIN_LIBDIR}" ${X86_64_LDCONFIG}`
if [[ $? == 0 ]] ; then
	printf "\tYes. GLIBC hard code fix already applied.\n"
elif [[ $? == 1 ]] ; then
	printf "\tGLIBC hard code fix not applied, attempting to fix via sed...\n"

	sed "s#/lib/ld-linux.so.2#${TOOLCHAIN_LIBDIR}/ld-linux.so.2#g" -i ${X86_64_LDCONFIG} || \
	{ printf "\tApplying hard code fix (32) failed.${REPORT_BUG_EXIT}" ; exit 1 ; }

	sed "s#/lib64/ld-linux-x86-64.so.2#${TOOLCHAIN_LIBDIR}/ld-linux-x86-64.so.2#g" -i ${X86_64_LDCONFIG} || \
	{ printf "\tApplying hard code fix (64) failed.${REPORT_BUG_EXIT}" ; exit 1 ; }



	printf "\tGLIBC hard code fix now applied.\n"
else
	printf "\tError detecting if GLIBC is hard coded.${REPORT_BUG_EXIT}"
	exit 1
fi
}

#
# End of GLIBC hard code fix

#
# Prepare GCC
#

# Not the best way to check if GCC is patched
# May break with future GCC updates
# Works for now, suggestions welcome
# Fixes GCC bug #58638
check_gcc_pic_patch ()
{
	unset PIC_PATCH_APPLIED

	printf "\n\tChecking if gcc/libstdc++-v3 is already patched...\n"

	PIC_CONF_NUM="$(grep 'glibcxx_lt_pic_flag="-prefer-pic"' \
	${GCC_TOOLCHAIN_SRCDIR}/libstdc++-v3/configure | wc -l)"

	PIC_CONF_AC_NUM="$(grep 'glibcxx_lt_pic_flag="-prefer-pic"' \
	${GCC_TOOLCHAIN_SRCDIR}/libstdc++-v3/configure.ac | wc -l)"

if [[ ${PIC_CONF_NUM} == 1 && ${PIC_CONF_AC_NUM} == 1 ]] ; then
	printf "\tlibstdc++-v3 PIC patch not applied. Applying...\n"
	cd ${GCC_TOOLCHAIN_SRCDIR}

	patch -p1 < ${GCC_PIC_PATCH} || \
	{ printf "\tlibstdc++-v3 PIC patch failed.${REPORT_BUG_EXIT}" ; exit 1 ; }

elif [[ ${PIC_CONF_NUM} == 2 && ${PIC_CONF_AC_NUM} == 2 ]] ; then
	printf "\tlibstdc++-v3 PIC patch already applied.\n"
else
	printf "\tgcc/libstdc++-v3 patch failed.${REPORT_BUG_EXIT}"
	exit 1
fi
}

# Suggestions welcome on a better way to do this
check_ld_linker_path ()
{
	GCC_CONF_32_H="${GCC_TOOLCHAIN_SRCDIR}/gcc/config/i386/linux.h"
	GCC_CONF_64_H="${GCC_TOOLCHAIN_SRCDIR}/gcc/config/i386/linux64.h"

	printf "\n\tIs GCC using the proper linker?\n"

	# 32-bit hard link fix
	# Change hard link from /lib/ld-linux-so.2 to $TOOLCHAIN_LIBDIR/ld-linux.so.2
	CHECK_GCC_HARDLINK_32=`grep "${TOOLCHAIN_LIBDIR}" ${GCC_CONF_32_H}`
if [[ $? == 0 ]] ; then
	printf "\tYes. 32-bit GCC linker fix already applied.\n"
elif [[ $? == 1 ]] ; then
	printf "\t32-bit GCC linker fix not applied, attempting to fix via sed...\n"

	sed "s#/lib/ld-linux.so.2#${TOOLCHAIN_LIBDIR}/ld-linux.so.2#g" -i ${GCC_CONF_32_H} || \
	{ printf "\tApplying 32-bit linker fix failed.${REPORT_BUG_EXIT}" ; exit 1 ; }

	printf "\t32-bit GCC linker fix now applied.\n"
else
	printf "\tError detecting if GCC is using proper linker.${REPORT_BUG_EXIT}"
	exit 1
fi

	# 64-bit hard link fix
	# Change hard link from /lib/ld-linux-x86-64.so.2 to $TOOLCHAIN_LIBDIR/ld-linux-x86-64.so.2
	CHECK_GCC_HARDLINK_64=`grep "${TOOLCHAIN_LIBDIR}" ${GCC_CONF_64_H}`
if [[ $? == 0 ]] ; then
	printf "\tYes. 64-bit GCC linker fix already applied.\n"
elif [[ $? == 1 ]] ; then
	printf "\t64-bit GCC linker fix not applied, attempting to fix via sed...\n"

	sed "s#/lib64/ld-linux-x86-64.so.2#${TOOLCHAIN_LIBDIR}/ld-linux-x86-64.so.2#g" -i ${GCC_CONF_64_H} || \
	{ printf "\tApplying 64-bit linker fix failed.${REPORT_BUG_EXIT}" ; exit 1 ; }

	sed "s#/lib/ld-linux.so.2#${TOOLCHAIN_LIBDIR}/ld-linux.so.2#g" -i ${GCC_CONF_64_H} || \
	{ printf "\tApplying 64-bit linker fix failed.${REPORT_BUG_EXIT}" ; exit 1 ; }

	printf "\t64-bit GCC linker fix now applied.\n"
else
	printf "\tError detecting if GCC is using proper linker.${REPORT_BUG_EXIT}"
	exit 1
fi
}

prepare_gcc ()
{
	check_gcc_pic_patch
	check_ld_linker_path

	printf "\n\tCopying required libraries to GCC if needed.\n"
if [[ ! -d ${GCC_TOOLCHAIN_SRCDIR}/gmp ]] ; then
	printf "\tCopying GMP to GCC...\n"

	cp -pr ${GMP_TOOLCHAIN_SRCDIR} ${GCC_TOOLCHAIN_SRCDIR}/ || \
	{ printf "\tError copying GMP to GCC.${REPORT_BUG_EXIT}" ; exit 1 ; }
fi

if [[ ! -d ${GCC_TOOLCHAIN_SRCDIR}/mpfr ]] ; then
	printf "\tCopying MPFR to GCC...\n"

	cp -pr ${MPFR_TOOLCHAIN_SRCDIR} ${GCC_TOOLCHAIN_SRCDIR}/ || \
	{ printf "\tError copying MPFR to GCC.${REPORT_BUG_EXIT}" ; exit 1 ; }
fi

if [[ ! -d ${GCC_TOOLCHAIN_SRCDIR}/mpc ]] ; then
	printf "\tCopying MPC to GCC...\n"

	cp -pr ${MPC_TOOLCHAIN_SRCDIR} ${GCC_TOOLCHAIN_SRCDIR}/ || \
	{ printf "\tError copying MPC to GCC.${REPORT_BUG_EXIT}" ; exit 1 ; }
fi

if [[ ! -d ${GCC_TOOLCHAIN_SRCDIR}/isl ]] ; then
	printf "\tCopying ISL to GCC...\n"

	cp -pr ${ISL_TOOLCHAIN_SRCDIR} ${GCC_TOOLCHAIN_SRCDIR}/ || \
	{ printf "\tError copying ISL to GCC.${REPORT_BUG_EXIT}" ; exit 1 ; }
fi
}

#
# End of GCC preparation
#

#
# Linux kernel headers
#

# Always make sure headers are sanitized
install_linux_headers ()
{
	printf "\n\tInstalling kernel headers to ${TOOLCHAIN_BINDIR}/usr/include...\n"
	sleep 1

	cd ${LINUX_TOOLCHAIN_SRCDIR}
	make mrproper

if [[ ! -d "DESTDIR" ]] ; then
	mkdir -p DESTDIR
else
	rm -rf DESTDIR/*
fi

	make INSTALL_HDR_PATH="DESTDIR" headers_install

	mkdir -p ${TOOLCHAIN_BINDIR}/usr/include || \
	{ printf "\tError creating ${TOOLCHAIN_BINDIR}/include. Exiting.\n" ; exit 1 ; }

	cp -pr DESTDIR/include/* ${TOOLCHAIN_BINDIR}/usr/include/ || \
	{ printf "\tError installing kernel headers. Exiting.\n" ; exit 1 ; }

	LINUX_HEADERS_INSTALLED=1
	printf "\nLINUX_HEADERS_INSTALLED=${LINUX_HEADERS_INSTALLED}\n" >> ${TOOLCHAIN_CONFIG}
}

#
# End of installation of kernel headers
#

#
# First pass of Binutils
#

first_pass_binutils ()
{
	printf "\n\tBuilding first pass Binutils...\n"
	sleep 1

	prepare_binutils

	cd ${BINUTILS_TOOLCHAIN_SRCDIR}

if [[ ! -d "build" ]] ; then
	mkdir -p build
	cd build
else
	cd build
	make distclean
	rm -rf ${BINUTILS_TOOLCHAIN_SRCDIR}/build/*
fi

	../configure \
	--prefix=${TOOLCHAIN_BINDIR}/usr \
	--libdir=${TOOLCHAIN_LIBDIR} \
	--enable-gold \
	--enable-lto \
	--with-isl \
	--disable-nls \
	--disable-gdb \
	--disable-werror \
	--disable-shared || \
	{ printf "\n\tBinutils configure error. Exiting.\n" ; exit 1 ; }

	make -j${CORES} || \
	{ printf "\n\tBinutils compile error. Exiting.\n" ; exit 1 ; }
	make install || \
	{ printf "\n\tBinutils install error. Exiting.\n" ; exit 1 ; }
}

#
# End of Binutils first pass
#

#
# First pass of GLIBC GNU C library
#

first_pass_glibc ()
{
	printf "\n\tBuilding first pass GLIBC...\n"
	sleep 1

	cd ${GLIBC_TOOLCHAIN_SRCDIR}

if [[ ! -d "build" ]] ; then
	mkdir -p build
	cd build
else
	cd build
	make distclean
	rm -rf ${GLIBC_TOOLCHAIN_SRCDIR}/build/*
fi

	../configure \
	--prefix=${TOOLCHAIN_BINDIR}/usr \
	--libdir=${TOOLCHAIN_LIBDIR} \
	--with-binutils=${TOOLCHAIN_BINDIR}/usr/bin \
	--with-headers=${TOOLCHAIN_BINDIR}/usr/include || \
	{ printf "\n\tGLIBC configure error. Exiting.\n" ; exit 1 ; }

	make -j${CORES} || \
	{ printf "\n\tGLIBC compile error. Exiting.\n" ; exit 1 ; }

	make install || \
	{ printf "\n\tGLIBC install error. Exiting.\n" ; exit 1 ; }
}

#
# End of GLIBC first pass
#

#
# First pass of GCC
#

first_pass_gcc ()
{
	printf "\n\tBuilding first pass C/C++ compiler...\n"
	sleep 1

	prepare_gcc

	cd ${GCC_TOOLCHAIN_SRCDIR}

if [[ ! -d "build" ]] ; then
	mkdir -p build
	cd build
else
	cd build
	make distclean
	rm -rf ${GCC_TOOLCHAIN_SRCDIR}/build/*
fi

	AR=${TOOLCHAIN_BINDIR}/usr/bin/ar \
	AS=${TOOLCHAIN_BINDIR}/usr/bin/as \
	LD=${TOOLCHAIN_BINDIR}/usr/bin/ld \
	NM=${TOOLCHAIN_BINDIR}/usr/bin/nm \
	OBJCOPY=${TOOLCHAIN_BINDIR}/usr/bin/objcopy \
	OBJDUMP=${TOOLCHAIN_BINDIR}/usr/bin/objdump \
	NM=${TOOLCHAIN_BINDIR}/usr/bin/ld \
	RANLIB=${TOOLCHAIN_BINDIR}/usr/bin/ranlib \
	READELF=${TOOLCHAIN_BINDIR}/usr/bin/readelf \
	STRIP=${TOOLCHAIN_BINDIR}/usr/bin/strip \
	AR_FOR_TARGET=${TOOLCHAIN_BINDIR}/usr/bin/ar \
	AS_FOR_TARGET=${TOOLCHAIN_BINDIR}/usr/bin/as \
	LD_FOR_TARGET=${TOOLCHAIN_BINDIR}/usr/bin/ld \
	NM_FOR_TARGET=${TOOLCHAIN_BINDIR}/usr/bin/nm \
	OBJCOPY_FOR_TARGET=${TOOLCHAIN_BINDIR}/usr/bin/objcopy \
	OBJDUMP_FOR_TARGET=${TOOLCHAIN_BINDIR}/usr/bin/objdump \
	NM_FOR_TARGET=${TOOLCHAIN_BINDIR}/usr/bin/ld \
	RANLIB_FOR_TARGET=${TOOLCHAIN_BINDIR}/usr/bin/ranlib \
	READELF_FOR_TARGET=${TOOLCHAIN_BINDIR}/usr/bin/readelf \
	STRIP_FOR_TARGET=${TOOLCHAIN_BINDIR}/usr/bin/strip \
	../configure \
	--prefix=${TOOLCHAIN_BINDIR}/usr \
	--with-local-prefix=${TOOLCHAIN_BINDIR}/usr \
	--with-native-system-header-dir=${TOOLCHAIN_BINDIR}/usr/include \
	--libdir=${TOOLCHAIN_LIBDIR} \
	--enable-languages=c,c++ \
	--enable-gold \
	--enable-lto \
	--with-isl \
	--disable-nls \
	--disable-libatomic \
	--disable-libgomp \
	--disable-libmpx \
	--disable-libquadmath \
	--disable-libssp \
	--disable-libvtv  \
	--disable-libstdcxx-pch \
	--disable-libcilkrts \
	--disable-libitm \
	--disable-libsanitizer \
	--disable-multilib \
	--disable-werror \
	--disable-shared || \
	{ printf "\n\tConfigure error. Exiting.\n" ; exit 1 ; }

	make -j${CORES} || \
	{ printf "\n\tCompile error. Exiting.\n" ; exit 1 ; }

	make install || \
	{ printf "\n\tInstall error. Exiting.\n" ; exit 1 ; }
}

#
# End of GCC first pass
#

#
# Second pass of Binutils
#

second_pass_binutils ()
{
	printf "\n\tBuilding second pass Binutils...\n"
	sleep 1

	prepare_binutils

	cd ${BINUTILS_TOOLCHAIN_SRCDIR}

if [[ ! -d "build" ]] ; then
	mkdir -p build
	cd build
else
	cd build
	make distclean
	rm -rf ${BINUTILS_TOOLCHAIN_SRCDIR}/build/*
fi

	# Eliminates the need for 500 lines here
	printf "\n\tUpdating PATH var...\n"
	ORIG_PATH="$PATH"
	NEW_PATH="${TOOLCHAIN_BINDIR}/usr/bin:$PATH"
	PATH="${NEW_PATH}"
	printf "\tPATH now has new toolchain set first.\n"

	# --with-build-sysroot prevents linking to /usr
	# Not needed with GCC, already links to libs in ${TOOLCHAIN_LIBDIR}
	# Verified with ldd
	../configure \
	--with-build-sysroot=${TOOLCHAIN_BINDIR} \
	--prefix=${TOOLCHAIN_BINDIR}/usr \
	--libdir=${TOOLCHAIN_LIBDIR} \
	--enable-gold \
	--enable-lto \
	--with-isl \
	--disable-gdb \
	--disable-werror \
	--disable-shared || \
	{ printf "\n\tBinutils configure error. Exiting.\n" ; exit 1 ; }

	make -j${CORES} || \
	{ printf "\n\tBinutils compile error. Exiting.\n" ; exit 1 ; }
	make install || \
	{ printf "\n\tBinutils install error. Exiting.\n" ; exit 1 ; }
}

#
# End of Binutils second pass
#

#
# Second pass of GLIBC GNU C library
#

# FIXME: Still uses some /usr libs (chroot env may be only fix)
second_pass_glibc ()
{
	printf "\n\tBuilding second pass GLIBC...\n"
	sleep 1

	check_glibc_hardcode

	cd ${GLIBC_TOOLCHAIN_SRCDIR}

if [[ ! -d "build" ]] ; then
	mkdir -p build
	cd build
else
	cd build
	make distclean
	rm -rf ${GLIBC_TOOLCHAIN_SRCDIR}/build/*
fi

	# Half of these libraries still use /usr
	../configure \
	--prefix=${TOOLCHAIN_BINDIR}/usr \
	--libdir=${TOOLCHAIN_LIBDIR} \
	--with-headers=${TOOLCHAIN_BINDIR}/usr/include || \
	{ printf "\n\tGLIBC configure error. Exiting.\n" ; exit 1 ; }

	make -j${CORES} || \
	{ printf "\n\tGLIBC compile error. Exiting.\n" ; exit 1 ; }

	make install || \
	{ printf "\n\tGLIBC install error. Exiting.\n" ; exit 1 ; }
}

#
# End of GLIBC second pass
#

#
# Second pass of GCC
#

second_pass_gcc ()
{
	printf "\n\tBuilding Second pass C/C++ compiler...\n"
	sleep 1

	prepare_gcc

	cd ${GCC_TOOLCHAIN_SRCDIR}

if [[ ! -d "build" ]] ; then
	mkdir -p build
	cd build
else
	cd build
	make distclean
	rm -rf ${GCC_TOOLCHAIN_SRCDIR}/build/*
fi

	# libmpx fails to build (for now at least anyway, forget exact error)
	# libsanitizer may fail to build as well, turning off to be safe
	../configure \
	--prefix=${TOOLCHAIN_BINDIR}/usr \
	--with-local-prefix=${TOOLCHAIN_BINDIR}/usr \
	--with-native-system-header-dir=${TOOLCHAIN_BINDIR}/usr/include \
	--libdir=${TOOLCHAIN_LIBDIR} \
	--enable-languages=c,c++ \
	--enable-gold \
	--enable-lto \
	--with-isl \
	--disable-libmpx \
	--disable-libsanitizer \
	--disable-multilib \
	--disable-shared || \
	{ printf "\n\tConfigure error. Exiting.\n" ; exit 1 ; }

	make -j${CORES} || \
	{ printf "\n\tCompile error. Exiting.\n" ; exit 1 ; }

	make install || \
	{ printf "\n\tInstall error. Exiting.\n" ; exit 1 ; }
}

#
# End of GCC second pass
#

#
# Execute build
#

if [[ ${LIBDIR_SET} == 1 ]] ; then
	printf "\n\tLIBDIR already set.\n"
else
	prepare_libdir
fi

if [[ ${LINUX_HEADERS_INSTALLED} == 1 ]] ; then
	printf "\n\tLinux headers already installed.\n"
else
	install_linux_headers
fi

build_toolchain ()
{
	first_pass_binutils

	first_pass_glibc

	first_pass_gcc

	second_pass_binutils

	second_pass_glibc

	second_pass_gcc

	printf "\n\tToolchain built successfully! \n"
	printf "\n\tTo add the toolchain to your PATH, simply run the following: \n"
	printf "\texport PATH=${TOOLCHAIN_BINDIR}/usr/bin:$PATH\n"
	printf "\n\tTo make sure your new toolchain is in use, run: \n"
	printf "\t'ld --version' or 'gcc --version' without quotes.\n"

	printf "\n\tIf you would like to use the Gold linker by default,
\tRun the following:\n
\tln -sfv ${TOOLCHAIN_BINDIR}/usr/bin/ld.gold ln -sfv ${TOOLCHAIN_BINDIR}/usr/bin/ld\n"

	TOOLCHAIN_COMPLETE=1
	printf "\nTOOLCHAIN_COMPLETE=${TOOLCHAIN_COMPLETE}\n" >> ${TOOLCHAIN_CONFIG}
}

build_toolchain

if [[ ${TOOLCHAIN_COMPLETE} == 1 ]] ; then
	printf "\n\tNothing left to do. Exiting.\n"
fi

exit 0

#EOF
