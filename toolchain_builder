#!/usr/bin/env bash
#
# Copyright (C) 2016 Alec Ari <neotheuser@ymail.com>
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

# TODO: Finish initial toolchain
# TODO: Finish Binutils 2nd/3rd pass (Gold linker + LTO + ISL)
# TODO: Glibc 2nd/3rd pass
# TODO: GCC patch
# TODO: GCC 2nd/3rd pass (Gold linker + LTO + ISL)
# TODO: Change GCC to use linker in TOOLCHAIN_BINDIR, NOT HOST
# TODO: Possible long-term reach goal: Create a small chroot environment using git toolchain

# printf because this is a C program (not really, just don't like echo)
printf "	NTU's complete bleeding edge toolchain builder\n"
printf "	Copyright (C) 2016 Alec Ari\n"
sleep 3

# This is here to ensure we don't accidentally break something bad
printf "	Making sure we are not root...\n"
if [[ $EUID = 0 ]] ; then
	printf "	This script must not be run as root.\n"
	exit 1
else
	printf "	Not root. Good.\n"
fi

# Environment sanity
unset STARTDIR
STARTDIR="${PWD}"

if [[ -w $STARTDIR ]] ; then
	printf "	User has write permissions to $STARTDIR\n"
else
	printf "	Please switch to a non-root writeable directory, such as home.\n"
	exit 1
fi

# Load config if present
unset TOOLCHAIN_CONFIG
TOOLCHAIN_CONFIG="${STARTDIR}/toolchain_builder.config"
printf "	Checking for pre-existing config file...\n"
if [[ -a $TOOLCHAIN_CONFIG ]] ; then
	printf "	Config file found. Loading...\n"
	source $TOOLCHAIN_CONFIG
	printf "	Loaded.\n"
else
	printf "	Config file not found. Creating one.\n"
	touch $TOOLCHAIN_CONFIG
	echo "# Automatically generated by NTU's toolchain builder" &> $TOOLCHAIN_CONFIG
fi

# Redirect stdout (1) and stderr (2) to /dev/null (keep quiet)
# print error if type fails and exit with >0 exit status
check_prerequisites ()
{
if [[ $SYSTEM_OK == 1 ]] ; then
	printf "	System already checked for prerequisites, all ok.\n"
	return 0
else
	printf "	Checking system for prerequisites...\n"
	type make > /dev/null 2>&1 || { printf "	Cannot find make. Exiting.\n" ; exit 1 ; }
	type gcc > /dev/null 2>&1 || { printf "	Cannot find GCC. Exiting.\n" ; exit 1 ; }
	type g++ > /dev/null 2>&1 || { printf "	Cannot find G++. Exiting.\n" ; exit 1 ; }
	type ld > /dev/null 2>&1 || { printf "	Please install Binutils. Exiting.\n" ; exit 1 ; }
	type libtool > /dev/null 2>&1 || { printf "	Cannot find libtool. Exiting.\n" ; exit 1 ; }
	type wget > /dev/null 2>&1 || { printf "	Cannot find wget. Exiting.\n" ; exit 1 ; }
	type git > /dev/null 2>&1 || { printf "	Cannot find git. Exiting.\n" ; exit 1 ; }
	type patch > /dev/null 2>&1 || { printf "	Cannot find patch. Exiting.\n" ; exit 1 ; }
	type autoconf > /dev/null 2>&1 || { printf "	Cannot find autoconf. Exiting.\n" ; exit 1 ; }
	type automake > /dev/null 2>&1 || { printf "	Cannot find automake. Exiting.\n" ; exit 1 ; }
	type grep > /dev/null 2>&1 || { printf "	Cannot find grep. Exiting.\n" ; exit 1 ; }
	type gawk > /dev/null 2>&1 || { printf "	Cannot find gawk. Exiting.\n" ; exit 1 ; }
	printf "	Obvious required tools found.\n"
	SYSTEM_OK=1 && echo SYSTEM_OK=$SYSTEM_OK >> $TOOLCHAIN_CONFIG
fi
}
check_prerequisites

# Probably not the BEST way to check, but it gets the job done
check_toolchain ()
{
if [[ $GENTOO_PASS == 1 || $GENERIC_TRUE == 1 ]] ; then
	printf "	System already passed compiler check.\n"
else
	unset GENTOO_TRUE
	unset GENERIC_TRUE
	printf "	Is this a Gentoo system?\n"
	if [[ `ls /etc/env.d/gcc/config*` ]] ; then
		printf "	Yes.\n" && GENTOO_TRUE=1
	else
		printf "	No, assuming working toolchain.\n"
		GENERIC_TRUE=1 && echo GENERIC_TRUE=$GENERIC_TRUE >> $TOOLCHAIN_CONFIG
	fi

	unset GENTOO_PASS
	if [[ $GENTOO_TRUE == 1 ]] ; then
		config="`cat /etc/env.d/gcc/config*`"
		if [[ $config == *vanilla && $GENTOO_TRUE == 1 ]] ; then
			printf "	Good, vanilla toolchain.\n"
			GENTOO_PASS=1 && echo GENTOO_PASS=$GENTOO_PASS >> $TOOLCHAIN_CONFIG
		else
			printf "	Not vanilla GCC, this may cause a GCC build failure
	as -fPIC and potentially other CFLAGS are known to issues.
	You may comment the following line out at your own risk. If you do,
	please report your success, your feedback is greatly appreciated.\n"
		exit 1
		fi
	fi
fi
}
check_toolchain

# unset in case set previously
unset CFLAGS
unset CXXFLAGS

# srcdir is taken so we have to make this more unique
unset TOOLCHAIN_SRCDIR
unset TOOLCHAIN_BINDIR

unset LINUX_TOOLCHAIN_SRCDIR
unset BINUTILS_TOOLCHAIN_SRCDIR
unset GLIBC_TOOLCHAIN_SRCDIR
unset GCC_TOOLCHAIN_SRCDIR

unset BINUTILS_GIT
unset GLIBC_GIT
unset GCC_GIT
unset BINUTILS_GIT_BRANCH
unset GCC_GIT_BRANCH
unset GLIBC_GIT_BRANCH

unset LINUX_VER
unset LINUX_LOC
unset GMP_LOC
unset MPFR_LOC
unset MPC_LOC
unset ISL_LOC
unset GCC_PATCH_LOC

unset CORES

#
# User modifiable variables
#

TOOLCHAIN_SRCDIR="${STARTDIR}/toolchain-src"
TOOLCHAIN_BINDIR="${STARTDIR}/toolchain-bin"

LINUX_VER="4.8.10"
# if git: LINUX_TOOLCHAIN_SRCDIR="${TOOLCHAIN_SRCDIR}/linux"
LINUX_TOOLCHAIN_SRCDIR="${TOOLCHAIN_SRCDIR}/linux-${LINUX_VER}"

BINUTILS_TOOLCHAIN_SRCDIR="${TOOLCHAIN_SRCDIR}/binutils-gdb"
GLIBC_TOOLCHAIN_SRCDIR="${TOOLCHAIN_SRCDIR}/glibc"
GCC_TOOLCHAIN_SRCDIR="${TOOLCHAIN_SRCDIR}/gcc"
GMP_TOOLCHAIN_SRCDIR="${GCC_TOOLCHAIN_SRCDIR}/gmp"
MPFR_TOOLCHAIN_SRCDIR="${GCC_TOOLCHAIN_SRCDIR}/mpfr"
MPC_TOOLCHAIN_SRCDIR="${GCC_TOOLCHAIN_SRCDIR}/mpc"
ISL_TOOLCHAIN_SRCDIR="${GCC_TOOLCHAIN_SRCDIR}/isl"

BINUTILS_GIT="git://sourceware.org/git/binutils-gdb.git"
GLIBC_GIT="git://sourceware.org/git/glibc.git"
GCC_GIT="git://gcc.gnu.org/git/gcc.git"

# Unstable branches
GCC_GIT_BRANCH="master"

# Stable branches
BINUTILS_GIT_BRANCH="binutils-2_27-branch"

if [[ $GENTOO_TRUE == 1 ]] ; then
	GLIBC_GIT_BRANCH="gentoo/2.24"
else
	GLIBC_GIT_BRANCH="release/2.24/master"
fi

# LINUX_GIT="git://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git"
# LINUX_GIT_BRANCH="master"
# Help speed things up by grabbing latest tarball of Linux instead of git
LINUX_LOC="https://cdn.kernel.org/pub/linux/kernel/v4.x/linux-${LINUX_VER}.tar.xz"

# GCC prerequisites
GMP_VER="6.1.1"
MPFR_VER="3.1.5"
MPC_VER="1.0.3"
ISL_VER="0.17.1"

GMP_LOC="https://ftp.gnu.org/gnu/gmp/gmp-${GMP_VER}.tar.xz"
MPFR_LOC="http://www.mpfr.org/mpfr-current/mpfr-${MPFR_VER}.tar.xz"
MPC_LOC="ftp://ftp.gnu.org/gnu/mpc/mpc-${MPC_VER}.tar.gz"
ISL_LOC="http://isl.gforge.inria.fr/isl-${ISL_VER}.tar.xz"

# XXX: TODO: Broken: FIXME: Fill this in
GCC_PATCH_LOC=""

# Fixes stupid and highly annoying libstdc++-v3 PIC compiling error
# XXX: TODO: Broken: FIXME
GCC_PATCH="${TOOLCHAIN_SRCDIR}/gcc-libstdc-pic.patch"

#
# End of user modifiable variables
#


#
# Fetch main sources (gmp, mpfr, and mpc are defined in GCC prepare section)
#

# Only called if not there
# if git: change this like the other fetch_* funcs
fetch_linux_headers ()
{
	printf "	Fetching Linux sources via wget...\n"
	wget -c $LINUX_LOC || { printf "	Error downloading Linux sources. Exiting.\n" ; exit 1 ; }
	printf "	Decompressing archive...\n"
	tar xf linux-${LINUX_VER}.tar.xz
	test -d linux-${LINUX_VER} || { printf "	Unexpected error: Linux source directory cannot be found. Exiting.\n" ; exit 1 ; }
}

# These are broken up in case some clone gets interrupted
fetch_binutils ()
{
	printf "	Fetching Binutils via git...\n"
	git clone $BINUTILS_GIT
if [[ -d $BINUTILS_TOOLCHAIN_SRCDIR ]] ; then
	cd $BINUTILS_TOOLCHAIN_SRCDIR
	git checkout $BINUTILS_GIT_BRANCH
else
	printf "	Error cloning Binutils. Exiting.\n"
	exit 1
fi
}

fetch_glibc ()
{
	printf "	Fetching Glibc via git...\n"
	git clone $GLIBC_GIT
if [[ -d $GLIBC_TOOLCHAIN_SRCDIR ]] ; then
	cd $GLIBC_TOOLCHAIN_SRCDIR
	git checkout $GLIBC_GIT_BRANCH
else
	printf "	Error cloning Glibc. Exiting.\n"
	exit 1
fi
}

fetch_gcc ()
{
	printf "	Fetching GCC via git...\n"
	git clone $GCC_GIT
if [[ -d $GCC_TOOLCHAIN_SRCDIR ]] ; then
	cd $GCC_TOOLCHAIN_SRCDIR
	git checkout $GCC_GIT_BRANCH
else
	printf "	Error cloning GCC. Exiting.\n"
	exit 1
fi
}

fetch_main ()
{
	fetch_linux_headers
	fetch_binutils
	fetch_gcc
	fetch_glibc
}


#
# Check sources, update if present, fresh download if not
#

check_linux_srcdir ()
{
	printf "	Checking for kernel source directory...\n"
if [[ -d "$LINUX_TOOLCHAIN_SRCDIR" ]] ; then
	printf "	Present.\n"
else
	printf "	Not found.\n"
	fetch_linux_headers
fi
}

check_binutils_srcdir ()
{
	printf "	Checking for Binutils git tree...\n"
if [[ -d "$BINUTILS_TOOLCHAIN_SRCDIR" ]] ; then
	printf "	Directory exists, updating tree...\n"
	cd $BINUTILS_TOOLCHAIN_SRCDIR
	git pull
else
	printf "	Not found.\n"
	fetch_binutils
fi
}

check_glibc_srcdir ()
{
	printf "	Checking for Glibc git tree...\n"
if [[ -d "$GLIBC_TOOLCHAIN_SRCDIR" ]] ; then
	printf "	Directory exists, updating tree...\n"
	cd $GLIBC_TOOLCHAIN_SRCDIR
	git pull
else
	printf "	Not found.\n"
	fetch_glibc
fi
}

check_gcc_srcdir ()
{
	printf "	Checking for GCC git tree...\n"
if [[ -d "$GCC_TOOLCHAIN_SRCDIR" ]] ; then
	printf "	Directory exists, updating tree...\n"
	cd $GCC_TOOLCHAIN_SRCDIR
	# In case patch is applied, always reset tree to ensure git pull works
	git reset --hard HEAD
	git pull
else
	printf "	Not found.\n"
	fetch_gcc
fi
}

check_src ()
{
	check_linux_srcdir
	check_binutils_srcdir
	check_gcc_srcdir
	check_glibc_srcdir
}

init_src ()
{
	printf "	Creating source work directory...\n"
	# In case bash screwed up at detecting write access?
	mkdir -p $TOOLCHAIN_SRCDIR || { printf "	Failed to create $TOOLCHAIN_SRCDIR. Exiting.\n" ; exit 1 ; }
	cd $TOOLCHAIN_SRCDIR
	fetch_main
}

printf "	Checking if $TOOLCHAIN_SRCDIR exists...\n"
if [[ -d "$TOOLCHAIN_SRCDIR" ]] ; then
	printf "	It does.\n"
	cd $TOOLCHAIN_SRCDIR
	check_src
else
	printf "	It does not, must be a first run.\n"
	printf "	Welcome! I really hope this script works for you.\n"
	printf "	Please report any bugs to the author of this program.\n"
	init_src
fi


#
# This is where the building starts
#

CORES=`cat /proc/cpuinfo | grep processor | wc -l`

# Always make sure this is a fresh build
# Extra second added for reading time
if [[ -d $TOOLCHAIN_BINDIR ]] ; then
	printf "	$TOOLCHAIN_BINDIR found. Deleting $TOOLCHAIN_BINDIR in 5 seconds.\n"
	printf "	This action cannot be undone.\n"
	printf "	Press Control+C to cancel.\n"
	sleep 1
	printf "	5.\n"
	sleep 1
	printf "	4.\n"
	sleep 1
	printf "	3.\n"
	sleep 1
	printf "	2.\n"
	sleep 1
	printf "	1.\n"
	sleep 1
	printf "	Cleaning $TOOLCHAIN_BINDIR...\n"
	rm -rf $TOOLCHAIN_BINDIR
	printf "	$TOOLCHAIN_BINDIR removed. Rebuilding toolchain...\n"
fi


#
# Linux kernel headers
#

# Always make sure headers are sanitized
install_linux_headers ()
{
	printf "	Installing kernel headers to ${TOOLCHAIN_BINDIR}/usr/include...\n"
	sleep 1
	cd $LINUX_TOOLCHAIN_SRCDIR
	make mrproper
if [[ ! -d "DESTDIR" ]] ; then
	mkdir -p DESTDIR
else
	rm -rf DESTDIR/*
fi
	make INSTALL_HDR_PATH="DESTDIR" headers_install
	mkdir -p ${TOOLCHAIN_BINDIR}/usr/include || { printf "	Error creating ${TOOLCHAIN_BINDIR}/include. Exiting.\n" ; exit 1 ; }
	cp -pr DESTDIR/include/* ${TOOLCHAIN_BINDIR}/usr/include/ || { printf "	Error installing kernel headers. Exiting.\n" ; exit 1 ; }
}

#
# First pass of Binutils
#

# Possible FIXME
first_pass_binutils ()
{
	printf "	Building first pass Binutils...\n"
	sleep 1
	cd $BINUTILS_TOOLCHAIN_SRCDIR
if [[ ! -d "build" ]] ; then
	mkdir -p build
	cd build
else
	cd build
	make distclean
	rm -rf ${BINUTILS_TOOLCHAIN_SRCDIR}/build/*
fi
	../configure \
	--prefix=${TOOLCHAIN_BINDIR}/usr \
	--disable-nls \
	--without-isl \
	--disable-gdb \
	--disable-werror \
	--disable-shared || { printf "	Binutils configure error. Exiting.\n" ; exit 1 ; }

	make -j${CORES} || { printf "	Binutils compile error. Exiting.\n" ; exit 1 ; }
	make install || { printf "	Binutils install error. Exiting.\n" ; exit 1 ; }
	BINUTILS_FIRST_PASS_SUCCESS=1
}

#
# First pass of Glibc GNU C library
#

first_pass_glibc ()
{
	printf "	Building first pass Glibc...\n"
	sleep 1
	cd $GLIBC_TOOLCHAIN_SRCDIR
if [[ ! -d "build" ]] ; then
	mkdir -p build
	cd build
else
	cd build
	make distclean
	rm -rf ${GLIBC_TOOLCHAIN_SRCDIR}/build/*
fi
	../configure \
	--prefix=${TOOLCHAIN_BINDIR}/usr \
	--with-binutils=${TOOLCHAIN_BINDIR}/usr/bin \
	--with-headers=${TOOLCHAIN_BINDIR}/usr/include || { printf "	Glibc configure error. Exiting.\n" ; exit 1 ; }

	make -j${CORES} || { printf "	Glibc compile error. Exiting.\n" ; exit 1 ; }
	make install || { printf "	Glibc install error. Exiting.\n" ; exit 1 ; }
	GLIBC_FIRST_PASS_SUCCESS=1
}


#
# Prepare GCC
#

# Not the best way, may break with future GCC updates
# Works for now, suggestions welcome
# TODO: Add patch
check_patch_gcc ()
{
	unset GCC_PATCH_APPLIED
	printf "	Checking if GCC is already patched...\n"
	PIC_CONF_NUM="$(grep 'glibcxx_lt_pic_flag="-prefer-pic"' ${GCC_TOOLCHAIN_SRCDIR}/libstdc++-v3/configure | wc -l)"
	PIC_CONF_AC_NUM="$(grep 'glibcxx_lt_pic_flag="-prefer-pic"' ${GCC_TOOLCHAIN_SRCDIR}/libstdc++-v3/configure.ac | wc -l)"
if [[ $PIC_CONF_NUM == 1 && $PIC_CONF_AC_NUM == 1 ]] ; then
	GCC_PATCH_APPLIED=0
elif [[ $PIC_CONF_NUM == 2 && $PIC_CONF_AC_NUM == 2 ]] ; then
	GCC_PATCH_APPLIED=1
else
	printf "	GCC patch failed, please report bug to script maintainer.\n"
	exit 1
fi
}

# Fixes GCC bug #58638
# TODO: Add patch
maybe_patch_gcc ()
{
	check_patch_gcc
if [[ $GCC_PATCH_APPLIED == 0 ]] ; then
	printf "	Patch not applied. Applying...\n"
	cd $GCC_TOOLCHAIN_SRCDIR
	patch -p1 < ${GCC_PATCH_LOC} || { printf "	GCC patch failed, please report bug to script maintainer.\n" ; exit 1 ; }
	GCC_PATCH_APPLIED=1
	printf "	Patch successful.\n"
else
	printf "	Already patched.\n"
fi
}

fetch_gmp ()
{
if [[ ! -d $GMP_TOOLCHAIN_SRCDIR ]] ; then
	printf "	Downloading GMP...\n"
	cd $GCC_TOOLCHAIN_SRCDIR
	wget -c $GMP_LOC || { printf "	Error downloading GMP-${GMP_VER}. Exiting.\n" ; exit 1 ; }
	tar xf gmp-${GMP_VER}.tar.xz
	mv -v gmp-${GMP_VER} gmp
	unset GMP_FIRST_DOWNLOAD
	GMP_FIRST_DOWNLOAD=1
else
	return 0
fi
}

fetch_mpfr ()
{
if [[ ! -d $MPFR_TOOLCHAIN_SRCDIR ]] ; then
	printf "	Downloading MPFR...\n"
	cd $GCC_TOOLCHAIN_SRCDIR
	wget -c $MPFR_LOC || { printf "	Error downloading MPFR-${MPFR_VER}. Exiting.\n" ; exit 1 ; }
	tar xf mpfr-${MPFR_VER}.tar.xz
	mv -v mpfr-${MPFR_VER} mpfr
	unset MPFR_FIRST_DOWNLOAD
	MPFR_FIRST_DOWNLOAD=1
else
	return 0
fi
}

fetch_mpc ()
{
if [[ ! -d $MPC_TOOLCHAIN_SRCDIR ]] ; then
	printf "	Downloading MPC...\n"
	cd $GCC_TOOLCHAIN_SRCDIR
	wget -c $MPC_LOC || { printf "	Error downloading MPC-${MPC_VER}.\n Exiting.\n" ; exit 1 ; }
	tar zxf mpc-${MPC_VER}.tar.gz
	mv -v mpc-${MPC_VER} mpc
	unset MPC_FIRST_DOWNLOAD
	MPC_FIRST_DOWNLOAD=1
else
	return 0
fi
}

fetch_gcc_prerequisites ()
{
	fetch_gmp
	fetch_mpfr
	fetch_mpc
	fetch_gcc_pic_patch
}

# fetch_isl Never called on GCC first pass (maybe)
fetch_isl ()
{
if [[ ! -d $ISL_TOOLCHAIN_SRCDIR ]] ; then
	cd $GCC_TOOLCHAIN_SRCDIR
	wget -c $ISL_LOC
	tar xf isl-${ISL_VER}.tar.xz
	mv -v isl-${ISL_VER} isl
else
	return 0
fi
}

#
# End of prepare gcc
#


gcc_first_pass ()
{
	printf "	Building first pass C/C++ compiler...\n"
	sleep 1
	fetch_gcc_prerequisites
	mkdir -p ${GCC_TOOLCHAIN_SRCDIR}/build
	cd ${GCC_TOOLCHAIN_SRCDIR}/build
	../configure \
	--prefix=${TOOLCHAIN_BINDIR}/usr \
	--with-local-prefix=${TOOLCHAIN_BINDIR}/usr \
	--with-native-system-header-dir=${TOOLCHAIN_BINDIR}/usr/include \
	--disable-nls \
	--disable-shared \
	--disable-multilib \
	--disable-libatomic \
	--disable-libgomp \
	--disable-libmpx \
	--disable-libquadmath \
	--disable-libssp \
	--disable-libvtv  \
	--disable-libstdcxx-pch \
	--enable-languages=c,c++ \
	--disable-werror \
	--without-isl \
	--disable-libcilkrts \
	--disable-libitm \
	--disable-libsanitizer || { printf "	Configure error. Exiting.\n" ; exit 1 ; }

	make -j${CORES} || { printf "	Compile error. Exiting.\n" ; exit 1 ; }
	make install || { printf "	Install error. Exiting.\n" ; exit 1 ; }
	unset GMP_FIRST_DOWNLOAD
	unset MPFR_FIRST_DOWNLOAD
	unset MPC_FIRST_DOWNLOAD
	GCC_FIRST_PASS_SUCCESS=1
}


# TODO: Finish second pass (Binutils, Glibc, GCC)
# Do we really need a third pass? Can we get Gold+LTO+ISL without one? Time will tell.
determine_pass_gcc ()
{
	maybe_patch_gcc
if [[ $GMP_FIRST_DOWNLOAD == 1 && $MPFR_FIRST_DOWNLOAD == 1 && $MPC_FIRST_DOWNLOAD == 1 ]] ; then
	gcc_first_pass
elif [[ $GCC_FIRST_PASS_SUCCESS == 1 ]] ; then
	gcc_second_pass
	printf "	Final GCC is built.\n"
else
	printf "	Unable to determine what GCC stage to build.\n"
	printf "	Please report bug to script maintainer.\n"
	exit 1
fi
}


install_linux_headers

# TODO: Change to determine
first_pass_binutils

# TODO: Change to determine
first_pass_glibc

# FIXME: Uses host linker
# determine_pass_gcc
