#!/usr/bin/env bash
#
# Copyright (C) 2016 - 2017 Alec Ari <neotheuser@ymail.com>
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

# TODO: Possible long-term reach goal: Create a small chroot environment using git toolchain

# printf because this is a C program (not really, just don't like echo)
printf "	NTU's complete bleeding edge native x86/amd64 toolchain builder\n"
printf "	Copyright (C) 2016 - 2017 Alec Ari\n\n"
sleep 3

# This is here to ensure we don't accidentally break something bad
printf "	Making sure we are not root...\n"
if [[ ${EUID} = 0 ]] ; then
	printf "	This script must not be run as root.\n"
	exit 1
else
	printf "	Not root. Good.\n"
fi

# Environment sanity
unset STARTDIR
STARTDIR="${PWD}"

if [[ -w "${STARTDIR}" ]] ; then
	printf "	User has write permissions to ${STARTDIR}\n"
else
	printf "	Please switch to a non-root writeable directory, such as home.\n"
	exit 1
fi

# NOTICE: A value of 1 to the config file means true,
# while 0 means false. This logic is similar to:
# i.e. #define X_Y_Z 1 (for true) therefor NOT a typo

# Reduce lengthly printf lines
REPORT_BUG_EXIT="\n\tPlease report bug to script maintainer.\n\tExiting.\n"

# Only called if $TOOLCHAIN_CONFIG not found or first run
# You may modify these before running this script to your liking
generate_defaults ()
{
	unset CORES
	unset TOOLCHAIN_SRCDIR
	unset TOOLCHAIN_BINDIR
	unset TOOLCHAIN_PATCHDIR
	unset LINUX_VER
	unset GMP_VER
	unset MPFR_VER
	unset MPC_VER
	unset ISL_VER
	unset BINUTILS_GIT_BRANCH
	unset GLIBC_GIT_BRANCH
	unset GCC_GIT_BRANCH

	CORES=`cat /proc/cpuinfo | grep processor | wc -l`
	TOOLCHAIN_SRCDIR="${STARTDIR}/toolchain-src"
	TOOLCHAIN_BINDIR="${STARTDIR}/toolchain-bin"
	TOOLCHAIN_PATCHDIR="${STARTDIR}/patches"
	LINUX_VER="4.8.11"
	GMP_VER="6.1.1"
	MPFR_VER="3.1.5"
	MPC_VER="1.0.3"
	ISL_VER="0.17.1"
	BINUTILS_GIT_BRANCH="master"
	GLIBC_GIT_BRANCH="release/2.24/master"
	GCC_GIT_BRANCH="master"

	printf "# Automatically generated by NTU's toolchain builder\n" &> ${TOOLCHAIN_CONFIG}
	printf "# Please use care when modifying this file\n" >> ${TOOLCHAIN_CONFIG}
	printf "# All paths must be absolute! \n" >> ${TOOLCHAIN_CONFIG}

#
# DO NOT MODIFY: Edit above values instead
# or config file if this is not your first rodeo
#

printf "
CORES="$CORES"\n
TOOLCHAIN_SRCDIR="${TOOLCHAIN_SRCDIR}"
TOOLCHAIN_BINDIR="${TOOLCHAIN_BINDIR}"
TOOLCHAIN_PATCHDIR="${TOOLCHAIN_PATCHDIR}"\n
LINUX_VER="${LINUX_VER}"\n
GMP_VER="${GMP_VER}"
MPFR_VER="${MPFR_VER}"
MPC_VER="${MPC_VER}"
ISL_VER="${ISL_VER}"\n
BINUTILS_GIT_BRANCH="${BINUTILS_GIT_BRANCH}"
GLIBC_GIT_BRANCH="${GLIBC_GIT_BRANCH}"
GCC_GIT_BRANCH="${GCC_GIT_BRANCH}"\n" >> ${TOOLCHAIN_CONFIG}

	source ${TOOLCHAIN_CONFIG}
}


# Load config if present, generate if not
unset TOOLCHAIN_CONFIG
TOOLCHAIN_CONFIG="${STARTDIR}/toolchain_builder.config"
printf "	Checking for pre-existing config file...\n"
if [[ -f "${TOOLCHAIN_CONFIG}" ]] ; then
	printf "	Config file found. Loading...\n"
	source ${TOOLCHAIN_CONFIG}
	printf "	Loaded.\n"
else
	printf "	Config file not found. Creating one.\n"
	touch ${TOOLCHAIN_CONFIG}
	generate_defaults
fi

# Redirect stdout (1) and stderr (2) to /dev/null (keep quiet)
# print error if type fails and exit with >0 exit status
if [[ ${SYSTEM_OK} == 1 ]] ; then
	printf "	System already checked for prerequisites, all ok.\n"
else
	printf "	Checking system for prerequisites...\n"
	type make > /dev/null 2>&1 || { printf "	Cannot find make. Exiting.\n" ; exit 1 ; }
	type gcc > /dev/null 2>&1 || { printf "	Cannot find GCC. Exiting.\n" ; exit 1 ; }
	type g++ > /dev/null 2>&1 || { printf "	Cannot find G++. Exiting.\n" ; exit 1 ; }
	type ld > /dev/null 2>&1 || { printf "	Please install Binutils. Exiting.\n" ; exit 1 ; }
	type libtool > /dev/null 2>&1 || { printf "	Cannot find libtool. Exiting.\n" ; exit 1 ; }
	type wget > /dev/null 2>&1 || { printf "	Cannot find wget. Exiting.\n" ; exit 1 ; }
	type git > /dev/null 2>&1 || { printf "	Cannot find git. Exiting.\n" ; exit 1 ; }
	type patch > /dev/null 2>&1 || { printf "	Cannot find patch. Exiting.\n" ; exit 1 ; }
	type autoconf > /dev/null 2>&1 || { printf "	Cannot find autoconf. Exiting.\n" ; exit 1 ; }
	type automake > /dev/null 2>&1 || { printf "	Cannot find automake. Exiting.\n" ; exit 1 ; }
	type grep > /dev/null 2>&1 || { printf "	Cannot find grep. Exiting.\n" ; exit 1 ; }
	type gawk > /dev/null 2>&1 || { printf "	Cannot find gawk. Exiting.\n" ; exit 1 ; }
	type sed > /dev/null 2>&1 || { printf "	Cannot find sed. Exiting.\n" ; exit 1 ; }
	printf "	Obvious required tools found.\n"

# Only x86/amd64 are supported due to GCC hard links
# See function check_ld_linker_path for more info
	printf "	Detecting kernel bitness...\n"
	unset ARCH_UNAME
	ARCH_UNAME=`uname -m`
	if [[ ${ARCH_UNAME} == *64 ]] ; then
		printf "	64-bit\n"
	elif [[ ${ARCH_UNAME} == *86 ]] ; then
		printf "	32-bit\n"
	else
		printf "	Unable to detect bitness.\n"
		printf "	Only x86 and amd64 platforms supported.\n"
		exit 1
	fi
	SYSTEM_OK=1
	printf "\nARCH_UNAME=${ARCH_UNAME}\n" >> ${TOOLCHAIN_CONFIG}
	printf "\nSYSTEM_OK="${SYSTEM_OK}"\n" >> ${TOOLCHAIN_CONFIG}
fi

# Probably not the BEST way to check, but it gets the job done
if [[ ${GENTOO_PASS} == 1 || ${GENERIC_TRUE} == 1 ]] ; then
	printf "	System already passed compiler check.\n"
else
	unset GENTOO_TRUE
	unset GENERIC_TRUE
	printf "	Is this a Gentoo system?\n"
	if [[ `ls /etc/env.d/gcc/config*` ]] ; then
		printf "	Yes.\n" && GENTOO_TRUE=1
	else
		printf "	No, assuming working toolchain.\n"
		GENERIC_TRUE=1
		printf "\nGENERIC_TRUE=${GENERIC_TRUE}\n" >> ${TOOLCHAIN_CONFIG}
	fi

	unset GENTOO_PASS
	if [[ ${GENTOO_TRUE} == 1 ]] ; then
		GCC_ENV_CONF="`cat /etc/env.d/gcc/config*`"
		if [[ ${GCC_ENV_CONF} == *vanilla && ${GENTOO_TRUE} == 1 ]] ; then
			printf "	Good, vanilla toolchain.\n"
			GENTOO_PASS=1
			printf "\nGENTOO_PASS=${GENTOO_PASS}\n" >> ${TOOLCHAIN_CONFIG}
		else
			printf "	Not vanilla GCC, this may cause a GCC build failure
	as -fPIC and potentially other CFLAGS are known to issues.
	You may comment the following line out at your own risk. If you do,
	please report your success, your feedback is greatly appreciated.\n"
		exit 1
		fi
	fi
fi

# If complete toolchain already exists, do not clean
# If interrupted, always restart
if [[ -d "${TOOLCHAIN_BINDIR}" && ${TOOLCHAIN_COMPLETE} != 1 ]] ; then
	printf "	${TOOLCHAIN_BINDIR} found.\n\n"
	printf "	Toolchain build hung up unexpectedly.\n"
	printf "	Deleting ${TOOLCHAIN_BINDIR} and \n\t${TOOLCHAIN_CONFIG} in 10 seconds.\n\n"
	printf "	This action cannot be undone.\n"
	printf "	Press Control+C to cancel.\n"
	printf "	10.\n"
	sleep 1
	printf "	9.\n"
	sleep 1
	printf "	8.\n"
	sleep 1
	printf "	7.\n"
	sleep 1
	printf "	6.\n"
	sleep 1
	printf "	5.\n"
	sleep 1
	printf "	4.\n"
	sleep 1
	printf "	3.\n"
	sleep 1
	printf "	2.\n"
	sleep 1
	printf "	1.\n"
	sleep 1
	printf "	Cleaning ${TOOLCHAIN_BINDIR} and \n\t${TOOLCHAIN_CONFIG}...\n\n"
	rm -rf ${TOOLCHAIN_BINDIR}
	rm -rf ${TOOLCHAIN_CONFIG}
	printf "	${TOOLCHAIN_BINDIR} and \n\t${TOOLCHAIN_CONFIG} removed. Please restart the script.\n"
	exit 0
elif [[ -d "${TOOLCHAIN_BINDIR}" && ${SECOND_PASS_GCC_SUCCESS} == 1 ]] ; then
	printf "	Toolchain already built.\n"
	printf "	${TOOLCHAIN_BINDIR} must be removed manually to proceed.\n"
	printf "	Nothing to do. Exiting.\n"
	exit 0
fi

# unset in case set previously
unset CFLAGS
unset CXXFLAGS
unset LDFLAGS

unset LINUX_TOOLCHAIN_SRCDIR
unset BINUTILS_TOOLCHAIN_SRCDIR
unset GLIBC_TOOLCHAIN_SRCDIR
unset GCC_TOOLCHAIN_SRCDIR
unset GMP_TOOLCHAIN_SRCDIR
unset MPFR_TOOLCHAIN_SRCDIR
unset MPC_TOOLCHAIN_SRCDIR
unset ISL_TOOLCHAIN_SRCDIR

unset BINUTILS_GIT
unset GLIBC_GIT
unset GCC_GIT

unset LINUX_LOC
unset GMP_LOC
unset MPFR_LOC
unset MPC_LOC
unset ISL_LOC
unset GCC_PIC_PATCH

#
# DO NOT MODIFY: Edit the config file instead
#

BINUTILS_TOOLCHAIN_SRCDIR="${TOOLCHAIN_SRCDIR}/binutils-gdb"
GLIBC_TOOLCHAIN_SRCDIR="${TOOLCHAIN_SRCDIR}/glibc"
GCC_TOOLCHAIN_SRCDIR="${TOOLCHAIN_SRCDIR}/gcc"
GMP_TOOLCHAIN_SRCDIR="${TOOLCHAIN_SRCDIR}/gmp"
MPFR_TOOLCHAIN_SRCDIR="${TOOLCHAIN_SRCDIR}/mpfr"
MPC_TOOLCHAIN_SRCDIR="${TOOLCHAIN_SRCDIR}/mpc"
ISL_TOOLCHAIN_SRCDIR="${TOOLCHAIN_SRCDIR}/isl"

BINUTILS_GIT="git://sourceware.org/git/binutils-gdb.git"
GLIBC_GIT="git://sourceware.org/git/glibc.git"
GCC_GIT="git://gcc.gnu.org/git/gcc.git"

LINUX_TOOLCHAIN_SRCDIR="${TOOLCHAIN_SRCDIR}/linux-${LINUX_VER}"
LINUX_LOC="https://cdn.kernel.org/pub/linux/kernel/v4.x/linux-${LINUX_VER}.tar.xz"

GMP_LOC="https://ftp.gnu.org/gnu/gmp/gmp-${GMP_VER}.tar.xz"
MPFR_LOC="http://www.mpfr.org/mpfr-current/mpfr-${MPFR_VER}.tar.xz"
MPC_LOC="ftp://ftp.gnu.org/gnu/mpc/mpc-${MPC_VER}.tar.gz"
ISL_LOC="http://isl.gforge.inria.fr/isl-${ISL_VER}.tar.xz"

# Fixes stupid, highly annoying and also fatal, libstdc++-v3 PIC compiling error
# They should really mainline this patch as static builds are currently broken
GCC_PIC_PATCH="${TOOLCHAIN_PATCHDIR}/gcc-libstdc-pic.patch"

#
# Fetch any required sources
#

fetch_sources ()
{
	cd ${TOOLCHAIN_SRCDIR}
	printf "	Fetching sources if needed...\n"

	# Binutils sources
if [[ ! -d "${BINUTILS_TOOLCHAIN_SRCDIR}" ]] ; then
	printf "	Fetching Binutils via git...\n"
	git clone ${BINUTILS_GIT}
fi

	# Glibc sources
if [[ ! -d "${GLIBC_TOOLCHAIN_SRCDIR}" ]] ; then
	printf "	Fetching Glibc via git...\n"
	git clone ${GLIBC_GIT}
fi

	# GCC sources
if [[ ! -d "${GCC_TOOLCHAIN_SRCDIR}" ]] ; then
	printf "	Fetching GCC via git...\n"
	git clone ${GCC_GIT}
fi

	# Linux sources
if [[ ! -f "${TOOLCHAIN_SRCDIR}/linux-${LINUX_VER}.tar.xz" ]] ; then
	printf "	Downloading Linux sources via wget...\n"
	wget -c ${LINUX_LOC} || \
	{ printf "	Error downloading Linux sources. Exiting.\n" ; exit 1 ; }
fi

	# GMP sources
if [[ ! -f "${TOOLCHAIN_SRCDIR}/gmp-${GMP_VER}.tar.xz" ]] ; then
	printf "	Downloading GMP via wget...\n"
	wget -c ${GMP_LOC} || \
	{ printf "	Error downloading GMP-${GMP_VER}. Exiting.\n" ; exit 1 ; }
fi

	# MPFR sources
if [[ ! -f "${TOOLCHAIN_SRCDIR}/mpfr-${MPFR_VER}.tar.xz" ]] ; then
	printf "	Downloading MPFR via wget...\n"
	wget -c ${MPFR_LOC} || \
	{ printf "	Error downloading MPFR-${MPFR_VER}. Exiting.\n" ; exit 1 ; }
fi

	# MPC sources
if [[ ! -f "${TOOLCHAIN_SRCDIR}/mpc-${MPC_VER}.tar.gz" ]] ; then
	printf "	Downloading MPC via wget...\n"
	wget -c ${MPC_LOC} || \
	{ printf "	Error downloading MPC-${MPC_VER}.\n Exiting.\n" ; exit 1 ; }
fi

	# ISL sources
if [[ ! -f "${TOOLCHAIN_SRCDIR}/isl-${ISL_VER}.tar.xz" ]] ; then
	printf "	Downloading ISL via wget...\n"
	wget -c ${ISL_LOC} || \
	{ printf "      Error downloading ISL-${ISL_VER}.\n Exiting.\n" ; exit 1 ; }
fi
}

#
# End of fetch sources
#

#
# Unpack any required sources
#

prepare_sources ()
{
	printf "	Unpacking any sources if needed...\n"

if [[ ! -d "${LINUX_TOOLCHAIN_SRCDIR}" ]] ; then
	printf "	Decompressing Linux sources...\n"
	tar xf ${TOOLCHAIN_SRCDIR}/linux-${LINUX_VER}.tar.xz -C ${TOOLCHAIN_SRCDIR}
fi

if [[ ! -d "${GMP_TOOLCHAIN_SRCDIR}" ]] ; then
	printf "	Decompressing GMP...\n"
	tar xf ${TOOLCHAIN_SRCDIR}/gmp-${GMP_VER}.tar.xz -C ${TOOLCHAIN_SRCDIR}
	mv -v ${TOOLCHAIN_SRCDIR}/gmp-${GMP_VER} ${GMP_TOOLCHAIN_SRCDIR}
fi

if [[ ! -d "${MPFR_TOOLCHAIN_SRCDIR}" ]] ; then
	printf "	Decompressing MPFR...\n"
	tar xf ${TOOLCHAIN_SRCDIR}/mpfr-${MPFR_VER}.tar.xz -C ${TOOLCHAIN_SRCDIR}
	mv -v ${TOOLCHAIN_SRCDIR}/mpfr-${MPFR_VER} ${MPFR_TOOLCHAIN_SRCDIR}
fi

if [[ ! -d "${MPC_TOOLCHAIN_SRCDIR}" ]] ; then
	printf "	Decompressing MPC...\n"
	tar zxf ${TOOLCHAIN_SRCDIR}/mpc-${MPC_VER}.tar.gz -C ${TOOLCHAIN_SRCDIR}
	mv -v ${TOOLCHAIN_SRCDIR}/mpc-${MPC_VER} ${MPC_TOOLCHAIN_SRCDIR}
fi

if [[ ! -d "${ISL_TOOLCHAIN_SRCDIR}" ]] ; then
	printf "	Decompressing ISL...\n"
	tar xf ${TOOLCHAIN_SRCDIR}/isl-${ISL_VER}.tar.xz -C ${TOOLCHAIN_SRCDIR}
	mv -v ${TOOLCHAIN_SRCDIR}/isl-${ISL_VER} ${ISL_TOOLCHAIN_SRCDIR}
fi
}

#
# End of unpack sources
#

#
# Verify sources
#

verify_sources ()
{
	printf "	Verifying sources...\n"

	test -d ${LINUX_TOOLCHAIN_SRCDIR} || \
	{ printf "	Unexpected error: ${LINUX_TOOLCHAIN_SRCDIR} cannot be found.${REPORT_BUG_EXIT}" ; exit 1 ; }

	test -d ${GMP_TOOLCHAIN_SRCDIR} || \
	{ printf "	Unexpected error: ${GMP_TOOLCHAIN_SRCDIR} cannot be found.${REPORT_BUG_EXIT}" ; exit 1 ; }

	test -d ${MPFR_TOOLCHAIN_SRCDIR} || \
	{ printf "	Unexpected error: ${MPFR_TOOLCHAIN_SRCDIR} cannot be found.${REPORT_BUG_EXIT}" ; exit 1 ; }

	test -d ${MPC_TOOLCHAIN_SRCDIR} || \
	{ printf "	Unexpected error: ${MPC_TOOLCHAIN_SRCDIR} cannot be found.${REPORT_BUG_EXIT}" ; exit 1 ; }

	test -d ${ISL_TOOLCHAIN_SRCDIR} || \
	{ printf "	Unexpected error: ${ISL_TOOLCHAIN_SRCDIR} cannot be found.${REPORT_BUG_EXIT}" ; exit 1 ; }

	test -d ${BINUTILS_TOOLCHAIN_SRCDIR} || \
	{ printf "	Unexpected error: ${BINUTILS_TOOLCHAIN_SRCDIR} cannot be found.${REPORT_BUG_EXIT}" ; exit 1 ; }

	test -d ${GLIBC_TOOLCHAIN_SRCDIR} || \
	{ printf "	Unexpected error: ${GLIBC_TOOLCHAIN_SRCDIR} cannot be found.${REPORT_BUG_EXIT}" ; exit 1 ; }

	test -d ${GCC_TOOLCHAIN_SRCDIR} || \
	{ printf "	Unexpected error: ${GCC_TOOLCHAIN_SRCDIR} cannot be found.${REPORT_BUG_EXIT}" ; exit 1 ; }

	printf "	All sources verified.\n"
}

#
# End of verify sources

#
# Update git repositories
#

# Have git pull run twice in case branches changed, sometimes pull needs another pass
# Reset source trees every time just in case we changed something
update_binutils ()
{
	printf "	Updating Binutils...\n"
	cd ${BINUTILS_TOOLCHAIN_SRCDIR}
	git reset --hard HEAD
	git pull
	git checkout ${BINUTILS_GIT_BRANCH}
	git pull
}

update_glibc ()
{
	printf "	Updating Glibc...\n"
	cd ${GLIBC_TOOLCHAIN_SRCDIR}
	git reset --hard HEAD
	git pull
	git checkout ${GLIBC_GIT_BRANCH}
	git pull
}

update_gcc ()
{
	printf "	Updating GCC...\n"
	cd ${GCC_TOOLCHAIN_SRCDIR}
	git reset --hard HEAD
	git pull
	git checkout ${GCC_GIT_BRANCH}
	git pull
}

update_sources ()
{
if [[ -d ${BINUTILS_TOOLCHAIN_SRCDIR} && -d ${GLIBC_TOOLCHAIN_SRCDIR} && -d ${GCC_TOOLCHAIN_SRCDIR} ]] ; then
	update_binutils
	update_glibc
	update_gcc
else
	printf "	Unexpected error: Cannot find git sources.${REPORT_BUG_EXIT}"
	exit 1
fi
}

#
# End of update sources
#

init_toolchain_srcdir ()
{
	printf "	Creating source work directory...\n"

	# In case of wonky config file, we always double check
	mkdir -p ${TOOLCHAIN_SRCDIR} || \
	{ printf "	Failed to create ${TOOLCHAIN_SRCDIR}. Exiting.\n" ; exit 1 ; }

}

printf "	Checking if ${TOOLCHAIN_SRCDIR} exists...\n"
if [[ -d "${TOOLCHAIN_SRCDIR}" ]] ; then
	printf "	It does.\n"
else
	printf "	It does not, must be your first rodeo.\n"
	printf "	Welcome! I really hope this script works for you.\n"
	printf "	Please report any bugs to the author of this program.\n"

	init_toolchain_srcdir
fi

fetch_sources

prepare_sources

verify_sources

update_sources

#
# This is where the building starts
#

#
# Create lib64 and a lib symlink to it if 64-bit
#

prepare_libdir()
{
if [[ ${ARCH_UNAME} == *64 ]] ; then
	if [[ ! -d ${TOOLCHAIN_BINDIR}/usr/lib64 ]] ; then

	mkdir -p ${TOOLCHAIN_BINDIR}/usr/lib64 || \
	{ printf "	Error creating ${TOOLCHAIN_BINDIR}/usr/lib64. Exiting.\n" ; exit 1 ; }

	printf "	Setting TOOLCHAIN_LIBDIR...\n"
	TOOLCHAIN_LIBDIR="${TOOLCHAIN_BINDIR}/usr/lib64"
	printf "\nTOOLCHAIN_LIBDIR=${TOOLCHAIN_LIBDIR}\n" >> ${TOOLCHAIN_CONFIG}

	printf "	Creating symlink...\n"
	ln -sfv ${TOOLCHAIN_BINDIR}/usr/lib64 ${TOOLCHAIN_BINDIR}/usr/lib

	LIBDIR_SET=1
	printf "LIBDIR_SET=${LIBDIR_SET}\n" >> ${TOOLCHAIN_CONFIG}
	fi
elif [[ ${ARCH_UNAME} == *86 ]] ; then
	if [[ ! -d ${TOOLCHAIN_BINDIR}/usr/lib64 ]] ; then

	mkdir -p ${TOOLCHAIN_BINDIR}/usr/lib || \
	{ printf "	Error creating ${TOOLCHAIN_BINDIR}/usr/lib. Exiting.\n" ; exit 1 ; }

	printf "	Setting TOOLCHAIN_LIBDIR...\n"
	TOOLCHAIN_LIBDIR="${TOOLCHAIN_BINDIR}/usr/lib"
	printf "\nTOOLCHAIN_LIBDIR=${TOOLCHAIN_LIBDIR}\n" >> ${TOOLCHAIN_CONFIG}

	LIBDIR_SET=1
	printf "LIBDIR_SET=${LIBDIR_SET}\n" >> ${TOOLCHAIN_CONFIG}
	fi
fi
}

#
# End of possible lib symlink to lib64
#

#
# Prepare Binutils
#

prepare_binutils ()
{
	printf "	Copying required libraries to Binutils if needed.\n"
if [[ ! -d ${BINUTILS_TOOLCHAIN_SRCDIR}/gmp ]] ; then
	printf "	Copying GMP to Binutils...\n"

	cp -pr ${GMP_TOOLCHAIN_SRCDIR} ${BINUTILS_TOOLCHAIN_SRCDIR}/ || \
	{ printf "	Error copying GMP to Binutils.${REPORT_BUG_EXIT}" ; exit 1 ; }
fi

if [[ ! -d ${BINUTILS_TOOLCHAIN_SRCDIR}/mpfr ]] ; then
	printf "	Copying MPFR to Binutils...\n"

	cp -pr ${MPFR_TOOLCHAIN_SRCDIR} ${BINUTILS_TOOLCHAIN_SRCDIR}/ || \
	{ printf "	Error copying MPFR to Binutils.${REPORT_BUG_EXIT}" ; exit 1 ; }
fi

if [[ ! -d ${BINUTILS_TOOLCHAIN_SRCDIR}/mpc ]] ; then
	printf "	Copying MPC to Binutils...\n"

	cp -pr ${MPC_TOOLCHAIN_SRCDIR} ${BINUTILS_TOOLCHAIN_SRCDIR}/ || \
	{ printf "	Error copying MPC to Binutils.${REPORT_BUG_EXIT}" ; exit 1 ; }
fi

if [[ ! -d ${BINUTILS_TOOLCHAIN_SRCDIR}/isl ]] ; then
	printf "	Copying ISL to Binutils...\n"

	cp -pr ${ISL_TOOLCHAIN_SRCDIR} ${BINUTILS_TOOLCHAIN_SRCDIR}/ || \
	{ printf "	Error copying ISL to Binutils.${REPORT_BUG_EXIT}" ; exit 1 ; }
fi
}

#
# End of Binutils preparation
#

#
# Prepare GCC
#

# Not the best way to check if GCC is patched
# May break with future GCC updates
# Works for now, suggestions welcome
# Fixes GCC bug #58638
check_gcc_pic_patch ()
{
	unset PIC_PATCH_APPLIED

	printf "	Checking if gcc/libstdc++-v3 is already patched...\n"

	PIC_CONF_NUM="$(grep 'glibcxx_lt_pic_flag="-prefer-pic"' \
	${GCC_TOOLCHAIN_SRCDIR}/libstdc++-v3/configure | wc -l)"

	PIC_CONF_AC_NUM="$(grep 'glibcxx_lt_pic_flag="-prefer-pic"' \
	${GCC_TOOLCHAIN_SRCDIR}/libstdc++-v3/configure.ac | wc -l)"

if [[ ${PIC_CONF_NUM} == 1 && ${PIC_CONF_AC_NUM} == 1 ]] ; then
	printf "	libstdc++-v3 PIC patch not applied. Applying...\n"
	cd ${GCC_TOOLCHAIN_SRCDIR}

	patch -p1 < ${GCC_PIC_PATCH} || \
	{ printf "	libstdc++-v3 PIC patch failed.${REPORT_BUG_EXIT}" ; exit 1 ; }

elif [[ ${PIC_CONF_NUM} == 2 && ${PIC_CONF_AC_NUM} == 2 ]] ; then
	printf "	libstdc++-v3 PIC patch already applied.\n"
else
	printf "	gcc/libstdc++-v3 patch failed.${REPORT_BUG_EXIT}"
	exit 1
fi
}

# Suggestions welcome on a better way to do this
check_ld_linker_path ()
{
	GCC_CONF_32_H="${GCC_TOOLCHAIN_SRCDIR}/gcc/config/i386/linux.h"
	GCC_CONF_64_H="${GCC_TOOLCHAIN_SRCDIR}/gcc/config/i386/linux64.h"

	printf "	Is GCC using the proper linker?\n"

	# 32-bit hard link fix
	# Change hard link from /lib/ld-linux-so.2 to $TOOLCHAIN_LIBDIR/ld-linux.so.2
	CHECK_HARDLINK_32=`grep "${TOOLCHAIN_LIBDIR}" ${GCC_CONF_32_H}`
if [[ $? == 0 ]] ; then
	printf "	Yes. 32-bit GCC linker fix already applied.\n"
elif [[ $? == 1 ]] ; then
	printf "	32-bit GCC linker fix not applied, attempting to fix via sed...\n"

	sed "s#/lib/ld-linux.so.2#${TOOLCHAIN_LIBDIR}/ld-linux.so.2#g" -i ${GCC_CONF_32_H} || \
	{ printf "	Applying 32-bit linker fix failed.${REPORT_BUG_EXIT}" ; exit 1 ; }

	printf "	32-bit GCC linker fix now applied.\n"
else
	printf "	Error detecting if GCC is using proper linker.${REPORT_BUG_EXIT}"
	exit 1
fi

	# 64-bit hard link fix
	# Change hard link from /lib/ld-linux-x86-64.so.2 to $TOOLCHAIN_LIBDIR/ld-linux-x86-64.so.2
	CHECK_HARDLINK_64=`grep "${TOOLCHAIN_LIBDIR}" ${GCC_CONF_64_H}`
if [[ $? == 0 ]] ; then
	printf "	Yes. 64-bit GCC linker fix already applied.\n"
elif [[ $? == 1 ]] ; then
	printf "	64-bit GCC linker fix not applied, attempting to fix via sed...\n"

	sed "s#/lib64/ld-linux-x86-64.so.2#${TOOLCHAIN_LIBDIR}/ld-linux-x86-64.so.2#g" -i ${GCC_CONF_64_H} || \
	{ printf "	Applying 64-bit linker fix failed.${REPORT_BUG_EXIT}" ; exit 1 ; }

	sed "s#/lib/ld-linux.so.2#${TOOLCHAIN_LIBDIR}/ld-linux.so.2#g" -i ${GCC_CONF_64_H} || \
	{ printf "	Applying 64-bit linker fix failed.${REPORT_BUG_EXIT}" ; exit 1 ; }

	printf "	64-bit GCC linker fix now applied.\n"
else
	printf "	Error detecting if GCC is using proper linker.${REPORT_BUG_EXIT}"
	exit 1
fi
}

prepare_gcc ()
{
	check_gcc_pic_patch
	check_ld_linker_path

	printf "	Copying required libraries to GCC if needed.\n"
if [[ ! -d ${GCC_TOOLCHAIN_SRCDIR}/gmp ]] ; then
	printf "	Copying GMP to GCC...\n"

	cp -pr ${GMP_TOOLCHAIN_SRCDIR} ${GCC_TOOLCHAIN_SRCDIR}/ || \
	{ printf "	Error copying GMP to GCC.${REPORT_BUG_EXIT}" ; exit 1 ; }
fi

if [[ ! -d ${GCC_TOOLCHAIN_SRCDIR}/mpfr ]] ; then
	printf "	Copying MPFR to GCC...\n"

	cp -pr ${MPFR_TOOLCHAIN_SRCDIR} ${GCC_TOOLCHAIN_SRCDIR}/ || \
	{ printf "	Error copying MPFR to GCC.${REPORT_BUG_EXIT}" ; exit 1 ; }
fi

if [[ ! -d ${GCC_TOOLCHAIN_SRCDIR}/mpc ]] ; then
	printf "	Copying MPC to GCC...\n"

	cp -pr ${MPC_TOOLCHAIN_SRCDIR} ${GCC_TOOLCHAIN_SRCDIR}/ || \
	{ printf "	Error copying MPC to GCC.${REPORT_BUG_EXIT}" ; exit 1 ; }
fi

if [[ ! -d ${GCC_TOOLCHAIN_SRCDIR}/isl ]] ; then
	printf "	Copying ISL to GCC...\n"

	cp -pr ${ISL_TOOLCHAIN_SRCDIR} ${GCC_TOOLCHAIN_SRCDIR}/ || \
	{ printf "	Error copying ISL to GCC.${REPORT_BUG_EXIT}" ; exit 1 ; }
fi
}

#
# End of GCC preparation
#

#
# Linux kernel headers
#

# Always make sure headers are sanitized
install_linux_headers ()
{
	printf "	Installing kernel headers to ${TOOLCHAIN_BINDIR}/usr/include...\n"
	sleep 1

	cd ${LINUX_TOOLCHAIN_SRCDIR}
	make mrproper

if [[ ! -d "DESTDIR" ]] ; then
	mkdir -p DESTDIR
else
	rm -rf DESTDIR/*
fi

	make INSTALL_HDR_PATH="DESTDIR" headers_install

	mkdir -p ${TOOLCHAIN_BINDIR}/usr/include || \
	{ printf "	Error creating ${TOOLCHAIN_BINDIR}/include. Exiting.\n" ; exit 1 ; }

	cp -pr DESTDIR/include/* ${TOOLCHAIN_BINDIR}/usr/include/ || \
	{ printf "	Error installing kernel headers. Exiting.\n" ; exit 1 ; }

	LINUX_HEADERS_INSTALLED=1
	printf "\nLINUX_HEADERS_INSTALLED=${LINUX_HEADERS_INSTALLED}\n" >> ${TOOLCHAIN_CONFIG}
}

#
# End of installation of kernel headers
#

#
# First pass of Binutils
#

first_pass_binutils ()
{
	printf "	Building first pass Binutils...\n"
	sleep 1

	prepare_binutils

	cd ${BINUTILS_TOOLCHAIN_SRCDIR}

if [[ ! -d "build" ]] ; then
	mkdir -p build
	cd build
else
	cd build
	make distclean
	rm -rf ${BINUTILS_TOOLCHAIN_SRCDIR}/build/*
fi

	../configure \
	--prefix=${TOOLCHAIN_BINDIR}/usr \
	--libdir=${TOOLCHAIN_LIBDIR} \
	--enable-gold \
	--enable-lto \
	--with-isl \
	--disable-nls \
	--disable-gdb \
	--disable-werror \
	--disable-shared || \
	{ printf "	Binutils configure error. Exiting.\n" ; exit 1 ; }

	make -j${CORES} || \
	{ printf "	Binutils compile error. Exiting.\n" ; exit 1 ; }
	make install || \
	{ printf "	Binutils install error. Exiting.\n" ; exit 1 ; }

	FIRST_PASS_BINUTILS_SUCCESS=1
	printf "\nFIRST_PASS_BINUTILS_SUCCESS=${FIRST_PASS_BINUTILS_SUCCESS}\n" >> ${TOOLCHAIN_CONFIG}
}

#
# End of Binutils first pass
#

#
# First pass of Glibc GNU C library
#

first_pass_glibc ()
{
	printf "	Building first pass Glibc...\n"
	sleep 1

	cd ${GLIBC_TOOLCHAIN_SRCDIR}

if [[ ! -d "build" ]] ; then
	mkdir -p build
	cd build
else
	cd build
	make distclean
	rm -rf ${GLIBC_TOOLCHAIN_SRCDIR}/build/*
fi

	../configure \
	--prefix=${TOOLCHAIN_BINDIR}/usr \
	--libdir=${TOOLCHAIN_LIBDIR} \
	--with-binutils=${TOOLCHAIN_BINDIR}/usr/bin \
	--with-headers=${TOOLCHAIN_BINDIR}/usr/include || \
	{ printf "	Glibc configure error. Exiting.\n" ; exit 1 ; }

	make -j${CORES} || \
	{ printf "	Glibc compile error. Exiting.\n" ; exit 1 ; }

	make install || \
	{ printf "	Glibc install error. Exiting.\n" ; exit 1 ; }

	FIRST_PASS_GLIBC_SUCCESS=1
	printf "\nFIRST_PASS_GLIBC_SUCCESS=${FIRST_PASS_GLIBC_SUCCESS}\n" >> ${TOOLCHAIN_CONFIG}
}

#
# End of Glibc first pass
#

#
# First pass of GCC
#

first_pass_gcc ()
{
	printf "	Building first pass C/C++ compiler...\n"
	sleep 1

	prepare_gcc

	cd ${GCC_TOOLCHAIN_SRCDIR}

if [[ ! -d "build" ]] ; then
	mkdir -p build
	cd build
else
	cd build
	make distclean
	rm -rf ${GCC_TOOLCHAIN_SRCDIR}/build/*
fi

	AR=${TOOLCHAIN_BINDIR}/usr/bin/ar \
	AS=${TOOLCHAIN_BINDIR}/usr/bin/as \
	LD=${TOOLCHAIN_BINDIR}/usr/bin/ld \
	NM=${TOOLCHAIN_BINDIR}/usr/bin/nm \
	OBJCOPY=${TOOLCHAIN_BINDIR}/usr/bin/objcopy \
	OBJDUMP=${TOOLCHAIN_BINDIR}/usr/bin/objdump \
	NM=${TOOLCHAIN_BINDIR}/usr/bin/ld \
	RANLIB=${TOOLCHAIN_BINDIR}/usr/bin/ranlib \
	READELF=${TOOLCHAIN_BINDIR}/usr/bin/readelf \
	STRIP=${TOOLCHAIN_BINDIR}/usr/bin/strip \
	AR_FOR_TARGET=${TOOLCHAIN_BINDIR}/usr/bin/ar \
	AS_FOR_TARGET=${TOOLCHAIN_BINDIR}/usr/bin/as \
	LD_FOR_TARGET=${TOOLCHAIN_BINDIR}/usr/bin/ld \
	NM_FOR_TARGET=${TOOLCHAIN_BINDIR}/usr/bin/nm \
	OBJCOPY_FOR_TARGET=${TOOLCHAIN_BINDIR}/usr/bin/objcopy \
	OBJDUMP_FOR_TARGET=${TOOLCHAIN_BINDIR}/usr/bin/objdump \
	NM_FOR_TARGET=${TOOLCHAIN_BINDIR}/usr/bin/ld \
	RANLIB_FOR_TARGET=${TOOLCHAIN_BINDIR}/usr/bin/ranlib \
	READELF_FOR_TARGET=${TOOLCHAIN_BINDIR}/usr/bin/readelf \
	STRIP_FOR_TARGET=${TOOLCHAIN_BINDIR}/usr/bin/strip \
	../configure \
	--prefix=${TOOLCHAIN_BINDIR}/usr \
	--with-local-prefix=${TOOLCHAIN_BINDIR}/usr \
	--with-native-system-header-dir=${TOOLCHAIN_BINDIR}/usr/include \
	--libdir=${TOOLCHAIN_LIBDIR} \
	--enable-languages=c,c++ \
	--enable-gold \
	--enable-lto \
	--with-isl \
	--disable-nls \
	--disable-libatomic \
	--disable-libgomp \
	--disable-libmpx \
	--disable-libquadmath \
	--disable-libssp \
	--disable-libvtv  \
	--disable-libstdcxx-pch \
	--disable-libcilkrts \
	--disable-libitm \
	--disable-libsanitizer \
	--disable-multilib \
	--disable-werror \
	--disable-shared || \
	{ printf "	Configure error. Exiting.\n" ; exit 1 ; }

	make -j${CORES} || \
	{ printf "	Compile error. Exiting.\n" ; exit 1 ; }

	make install || \
	{ printf "	Install error. Exiting.\n" ; exit 1 ; }

	FIRST_PASS_GCC_SUCCESS=1
	printf "\nFIRST_PASS_GCC_SUCCESS=${FIRST_PASS_GCC_SUCCESS}\n" >> ${TOOLCHAIN_CONFIG}
}

#
# End of GCC first pass
#

#
# Second pass of Binutils
#

second_pass_binutils ()
{
	printf "	Building second pass Binutils...\n"
	sleep 1

	prepare_binutils

	cd ${BINUTILS_TOOLCHAIN_SRCDIR}

if [[ ! -d "build" ]] ; then
	mkdir -p build
	cd build
else
	cd build
	make distclean
	rm -rf ${BINUTILS_TOOLCHAIN_SRCDIR}/build/*
fi

	CC=${TOOLCHAIN_BINDIR}/usr/bin/gcc \
	CXX=${TOOLCHAIN_BINDIR}/usr/bin/g++ \
	AR=${TOOLCHAIN_BINDIR}/usr/bin/ar \
	AS=${TOOLCHAIN_BINDIR}/usr/bin/as \
	LD=${TOOLCHAIN_BINDIR}/usr/bin/ld \
	NM=${TOOLCHAIN_BINDIR}/usr/bin/nm \
	OBJCOPY=${TOOLCHAIN_BINDIR}/usr/bin/objcopy \
	OBJDUMP=${TOOLCHAIN_BINDIR}/usr/bin/objdump \
	NM=${TOOLCHAIN_BINDIR}/usr/bin/ld \
	RANLIB=${TOOLCHAIN_BINDIR}/usr/bin/ranlib \
	READELF=${TOOLCHAIN_BINDIR}/usr/bin/readelf \
	STRIP=${TOOLCHAIN_BINDIR}/usr/bin/strip \
	CC_FOR_TARGET=${TOOLCHAIN_BINDIR}/usr/bin/gcc \
	CXX_FOR_TARGET=${TOOLCHAIN_BINDIR}/usr/bin/g++ \
	AR_FOR_TARGET=${TOOLCHAIN_BINDIR}/usr/bin/ar \
	AS_FOR_TARGET=${TOOLCHAIN_BINDIR}/usr/bin/as \
	LD_FOR_TARGET=${TOOLCHAIN_BINDIR}/usr/bin/ld \
	NM_FOR_TARGET=${TOOLCHAIN_BINDIR}/usr/bin/nm \
	OBJCOPY_FOR_TARGET=${TOOLCHAIN_BINDIR}/usr/bin/objcopy \
	OBJDUMP_FOR_TARGET=${TOOLCHAIN_BINDIR}/usr/bin/objdump \
	NM_FOR_TARGET=${TOOLCHAIN_BINDIR}/usr/bin/ld \
	RANLIB_FOR_TARGET=${TOOLCHAIN_BINDIR}/usr/bin/ranlib \
	READELF_FOR_TARGET=${TOOLCHAIN_BINDIR}/usr/bin/readelf \
	STRIP_FOR_TARGET=${TOOLCHAIN_BINDIR}/usr/bin/strip \
	../configure \
	--prefix=${TOOLCHAIN_BINDIR}/usr \
	--libdir=${TOOLCHAIN_LIBDIR} \
	--enable-gold \
	--enable-lto \
	--with-isl \
	--disable-gdb \
	--disable-werror || \
	{ printf "	Binutils configure error. Exiting.\n" ; exit 1 ; }

	make -j${CORES} || \
	{ printf "	Binutils compile error. Exiting.\n" ; exit 1 ; }
	make install || \
	{ printf "	Binutils install error. Exiting.\n" ; exit 1 ; }

	SECOND_PASS_BINUTILS_SUCCESS=1
	printf "\nSECOND_PASS_BINUTILS_SUCCESS=${SECOND_PASS_BINUTILS_SUCCESS}\n" >> ${TOOLCHAIN_CONFIG}
}

#
# End of Binutils second pass
#

#
# Second pass of Glibc GNU C library
#

second_pass_glibc ()
{
	printf "	Building second pass Glibc...\n"
	sleep 1

	cd ${GLIBC_TOOLCHAIN_SRCDIR}

if [[ ! -d "build" ]] ; then
	mkdir -p build
	cd build
else
	cd build
	make distclean
	rm -rf ${GLIBC_TOOLCHAIN_SRCDIR}/build/*
fi

	CC=${TOOLCHAIN_BINDIR}/usr/bin/gcc \
	CXX=${TOOLCHAIN_BINDIR}/usr/bin/g++ \
	AR=${TOOLCHAIN_BINDIR}/usr/bin/ar \
	AS=${TOOLCHAIN_BINDIR}/usr/bin/as \
	LD=${TOOLCHAIN_BINDIR}/usr/bin/ld \
	NM=${TOOLCHAIN_BINDIR}/usr/bin/nm \
	OBJCOPY=${TOOLCHAIN_BINDIR}/usr/bin/objcopy \
	OBJDUMP=${TOOLCHAIN_BINDIR}/usr/bin/objdump \
	NM=${TOOLCHAIN_BINDIR}/usr/bin/ld \
	RANLIB=${TOOLCHAIN_BINDIR}/usr/bin/ranlib \
	READELF=${TOOLCHAIN_BINDIR}/usr/bin/readelf \
	STRIP=${TOOLCHAIN_BINDIR}/usr/bin/strip \
	CC_FOR_TARGET=${TOOLCHAIN_BINDIR}/usr/bin/gcc \
	CXX_FOR_TARGET=${TOOLCHAIN_BINDIR}/usr/bin/g++ \
	AR_FOR_TARGET=${TOOLCHAIN_BINDIR}/usr/bin/ar \
	AS_FOR_TARGET=${TOOLCHAIN_BINDIR}/usr/bin/as \
	LD_FOR_TARGET=${TOOLCHAIN_BINDIR}/usr/bin/ld \
	NM_FOR_TARGET=${TOOLCHAIN_BINDIR}/usr/bin/nm \
	OBJCOPY_FOR_TARGET=${TOOLCHAIN_BINDIR}/usr/bin/objcopy \
	OBJDUMP_FOR_TARGET=${TOOLCHAIN_BINDIR}/usr/bin/objdump \
	NM_FOR_TARGET=${TOOLCHAIN_BINDIR}/usr/bin/ld \
	RANLIB_FOR_TARGET=${TOOLCHAIN_BINDIR}/usr/bin/ranlib \
	READELF_FOR_TARGET=${TOOLCHAIN_BINDIR}/usr/bin/readelf \
	STRIP_FOR_TARGET=${TOOLCHAIN_BINDIR}/usr/bin/strip \
	../configure \
	--prefix=${TOOLCHAIN_BINDIR}/usr \
	--libdir=${TOOLCHAIN_LIBDIR} \
	--with-binutils=${TOOLCHAIN_BINDIR}/usr/bin \
	--with-headers=${TOOLCHAIN_BINDIR}/usr/include || \
	{ printf "	Glibc configure error. Exiting.\n" ; exit 1 ; }

	make -j${CORES} || \
	{ printf "	Glibc compile error. Exiting.\n" ; exit 1 ; }

	make install || \
	{ printf "	Glibc install error. Exiting.\n" ; exit 1 ; }

	FIRST_PASS_GLIBC_SUCCESS=1
	printf "\nSECOND_PASS_GLIBC_SUCCESS=${SECOND_PASS_GLIBC_SUCCESS}\n" >> ${TOOLCHAIN_CONFIG}
}

#
# End of Glibc second pass
#

#
# Second pass of GCC
#

second_pass_gcc ()
{
	printf "	Building Second pass C/C++ compiler...\n"
	sleep 1

	prepare_gcc

	cd ${GCC_TOOLCHAIN_SRCDIR}

if [[ ! -d "build" ]] ; then
	mkdir -p build
	cd build
else
	cd build
	make distclean
	rm -rf ${GCC_TOOLCHAIN_SRCDIR}/build/*
fi

	CC=${TOOLCHAIN_BINDIR}/usr/bin/gcc \
	CXX=${TOOLCHAIN_BINDIR}/usr/bin/g++ \
	AR=${TOOLCHAIN_BINDIR}/usr/bin/ar \
	AS=${TOOLCHAIN_BINDIR}/usr/bin/as \
	LD=${TOOLCHAIN_BINDIR}/usr/bin/ld \
	NM=${TOOLCHAIN_BINDIR}/usr/bin/nm \
	OBJCOPY=${TOOLCHAIN_BINDIR}/usr/bin/objcopy \
	OBJDUMP=${TOOLCHAIN_BINDIR}/usr/bin/objdump \
	NM=${TOOLCHAIN_BINDIR}/usr/bin/ld \
	RANLIB=${TOOLCHAIN_BINDIR}/usr/bin/ranlib \
	READELF=${TOOLCHAIN_BINDIR}/usr/bin/readelf \
	STRIP=${TOOLCHAIN_BINDIR}/usr/bin/strip \
	CC_FOR_TARGET=${TOOLCHAIN_BINDIR}/usr/bin/gcc \
	CXX_FOR_TARGET=${TOOLCHAIN_BINDIR}/usr/bin/g++ \
	AR_FOR_TARGET=${TOOLCHAIN_BINDIR}/usr/bin/ar \
	AS_FOR_TARGET=${TOOLCHAIN_BINDIR}/usr/bin/as \
	LD_FOR_TARGET=${TOOLCHAIN_BINDIR}/usr/bin/ld \
	NM_FOR_TARGET=${TOOLCHAIN_BINDIR}/usr/bin/nm \
	OBJCOPY_FOR_TARGET=${TOOLCHAIN_BINDIR}/usr/bin/objcopy \
	OBJDUMP_FOR_TARGET=${TOOLCHAIN_BINDIR}/usr/bin/objdump \
	NM_FOR_TARGET=${TOOLCHAIN_BINDIR}/usr/bin/ld \
	RANLIB_FOR_TARGET=${TOOLCHAIN_BINDIR}/usr/bin/ranlib \
	READELF_FOR_TARGET=${TOOLCHAIN_BINDIR}/usr/bin/readelf \
	STRIP_FOR_TARGET=${TOOLCHAIN_BINDIR}/usr/bin/strip \
	../configure \
	--prefix=${TOOLCHAIN_BINDIR}/usr \
	--with-local-prefix=${TOOLCHAIN_BINDIR}/usr \
	--with-native-system-header-dir=${TOOLCHAIN_BINDIR}/usr/include \
	--libdir=${TOOLCHAIN_LIBDIR} \
	--enable-languages=c,c++ \
	--enable-gold \
	--enable-lto \
	--with-isl \
	--disable-multilib || \
	{ printf "	Configure error. Exiting.\n" ; exit 1 ; }

	make -j${CORES} || \
	{ printf "	Compile error. Exiting.\n" ; exit 1 ; }

	make install || \
	{ printf "	Install error. Exiting.\n" ; exit 1 ; }

	SECOND_PASS_GCC_SUCCESS=1
	printf "\nSECOND_PASS_GCC_SUCCESS=${SECOND_PASS_GCC_SUCCESS}\n" >> ${TOOLCHAIN_CONFIG}
}

#
# End of GCC second pass
#

#
# Use determine_* functions to see what's left to build
#

determine_pass_binutils ()
{
if [[ ${FIRST_PASS_BINUTILS_SUCCESS} != 1 ]] ; then
	first_pass_binutils
elif [[ ${FIRST_PASS_BINUTILS_SUCCESS} == 1 ]] ; then
	second_pass_binutils
elif [[ ${SECOND_PASS_BINUTILS_SUCCESS} == 1 ]] ; then
	printf "	Second Binutils pass is built.\n"
	printf "	Success! \n"
else
	printf "	Unable to determine what Binutils stage to build.${REPORT_BUG_EXIT}"
	exit 1
fi
}

determine_pass_glibc ()
{
if [[ ${FIRST_PASS_GLIBC_SUCCESS} != 1 ]] ; then
	first_pass_glibc
elif [[ ${FIRST_PASS_GLIBC_SUCCESS} == 1 ]] ; then
	second_pass_glibc
elif [[ ${SECOND_PASS_GLIBC_SUCCESS} == 1 ]] ; then
	printf "	Second GLIBC pass is built.\n"
	printf "	Success! \n"
else
	printf "	Unable to determine what Glibc stage to build.${REPORT_BUG_EXIT}"
	exit 1
fi
}

determine_pass_gcc ()
{
if [[ ${FIRST_PASS_GCC_SUCCESS} != 1 ]] ; then
	first_pass_gcc
elif [[ ${FIRST_PASS_GCC_SUCCESS} == 1 ]] ; then
	second_pass_gcc
elif [[ ${SECOND_PASS_GCC_SUCCESS} == 1 ]] ; then
	printf "	Second GCC pass is built.\n"
	printf "	Success! \n"

	TOOLCHAIN_COMPLETE=1
	printf "\nTOOLCHAIN_COMPLETE=${TOOLCHAIN_COMPLETE}\n" >> ${TOOLCHAIN_CONFIG}
else
	printf "	Unable to determine what GCC stage to build.${REPORT_BUG_EXIT}"
	exit 1
fi
}

#
# End of build functions
#

#
# Execute build
#

if [[ ${LIBDIR_SET} == 1 ]] ; then
	printf "	LIBDIR already set.\n"
else
	prepare_libdir
fi

if [[ ${LINUX_HEADERS_INSTALLED} == 1 ]] ; then
	printf "	Linux headers already installed.\n"
else
	install_linux_headers
fi

determine_pass_binutils

determine_pass_glibc

determine_pass_gcc

printf "\n\tToolchain built successfully! \n"
printf "\tTo add the toolchain to your PATH, simply run the following: \n"
printf "\texport PATH=${TOOLCHAIN_BINDIR}/usr/bin:$PATH\n"
printf "\tTo make sure your new toolchain is in use, run: \n"
printf "\t'ld --version' or 'gcc --version' without quotes.\n\n"
printf "\n\tNothing left to do. Exiting successfully.\n"
exit 0

#EOF
